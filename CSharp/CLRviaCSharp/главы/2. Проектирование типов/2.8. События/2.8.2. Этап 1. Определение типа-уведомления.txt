Этап 1. Определение типа для хранения всей дополнительной информации, передаваемой получателям уведомления о событии

Обычно стандартного уведомления о произошедшей определенной ситуации недостаточно. например, подписался на канал, а уведомление 
о новом ролике должна хранить в себе еще доп. инфу: название канала и ролика, время выхода, ссылка на ролик, превьюшка и т.д. Посему 
надо определить тип-уведомления, который хранил бы в себе всю эту информацию. Для этого она должна соблюдать несколько рекомендаций
и правил:
    1) тип-уведомления должен наследовать EventArgs. Это обязательно.
    2) тип-уведомление желательно должен иметь в конце имени приписку EventArgs, как интерфейсы I вначале. 
    3) доступ к любому полю определить только через свойства { get; }
    4) все поля закрыты (private) доступные только для чтения (redonly), чтобы данные точно не могли потеряться или
       быть изменены в процессе асинхронности

Пример: класс уведомления NewMailEventArgs, содержащий поля: отправителя (m_from), получателя (m_to) и тему (m_subject)
 
    internal class NewMailEventArgs : EventArgs 
    {
        public NewMailEventArgs(String from, String to, String subject) 
        {
            m_from = from; m_to = to; m_subject = subject;
        }
        
        private readonly String m_from, m_to, m_subject;

        public String From { get { return m_from; } }
        public String To { get { return m_to; } }
        public String Subject { get { return m_subject; } }
    }

ВАЖНОЕ Примечание: тип EventArgs из библиотеки классов  .NET Framework Class Library (FCL) выглядит так:

    [ComVisible(true), Serializable]
    public class EventArgs 
    {
        public static readonly EventArgs Empty = new EventArgs();
        public EventArgs() { }
    }

Он лишь служит базовым типом и в случае, когде нет нужды передавать хоть какую-нибудь дополнительную информацию о событии, 
можно обойтись и без создания нового класса и воспользоваться свойством EventArgs.Empty