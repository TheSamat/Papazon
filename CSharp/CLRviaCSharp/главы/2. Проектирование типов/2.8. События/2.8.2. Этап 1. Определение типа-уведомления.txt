Этап 1. Определение типа для хранения всей дополнительной информации, передаваемой получателям уведомления о событии

Обычно стандартного уведомления о произошедшей определенной ситуации недостаточно. например, подписался на канал, а уведомление 
о новом ролике должна хранить в себе еще доп. инфу: название канала и ролика, время выхода, ссылка на ролик, превьюшка и т.д. Посему 
надо определить тип-уведомления, который хранил бы в себе всю эту информацию. Для этого она должна соблюдать несколько рекомендаций
и правил:
    1) тип-уведомления должен наследовать EventArgs. Это обязательно.
    2) тип-уведомление желательно должен иметь в конце имени приписку EventArgs, как интерфейсы I вначале.
    3) содержать набор закрытых (private) полей доступных только для чтения (redonly), чтобы данные точно не могли потеряться или
       быть изменены в процессе асинхронности
    4) к каждому полю определить только свойства { get; }

событии, а само уведомление - класс, содержащий набор закрытых полей и набор открых неизменяемых 
(только для чтения) данных, который обязан быть наследован от System.EventArgs, а в названии класса иметь на конце EventArgs.

    internal class NewMailEventArgs : EventArgs 
    {
        public NewMailEventArgs(String from, String to, String subject) 
        {
           m_from = from; m_to = to; m_subject = subject;
        }
        private readonly String m_from, m_to, m_subject;

        public String From { get { return m_from; } }
        public String To { get { return m_to; } }
        public String Subject { get { return m_subject; } }
    }

это класс уведомления NewMailEventArgs, содержащий поля: отправителя (m_from), получателя (m_to) и тему (m_subject)


ВАЖНОЕ Примечание: тип EventArgs из библиотеки классов  .NET Framework Class Library (FCL) выглядит так:

    [ComVisible(true), Serializable]
    public class EventArgs {
      public static readonly EventArgs Empty = new EventArgs();
      public EventArgs() { }
    }

который лишь служит базовым типом и в случае, когде нет нужды передавать хоть какую-нибудь дополнительную информацию о событии, 
можно обойтись и без создания нового класса и воспользоваться свойством EventArgs.Empty (но хз, по мне лучшим вариантом является 
как раз таки расписание нового класса)