Теперь научимся определять тип, использующий событие, поддерживаемый другим типом. Создадим класс, на котором и потренеруемся:

    internal sealed class Fax {
        // Передаем конструктору объект MailManager
        public Fax(MailManager mm) 
        {
            // Создаем экземпляр делегата
            // EventHandler<NewMailEventArgs>,
            // ссылающийся на метод обратного вызова FaxMsg

            // Регистрируем обратный вызов для события NewMail 
            // объекта MailManager

            mm.NewMail += FaxMsg;
        }

        // MailManager вызывает этот метод для уведомления
        // объекта Fax о прибытии нового почтового сообщения
        private void FaxMsg(Object sender, NewMailEventArgs e) 
        {
            // 'sender' используется для взаимодействия с 
            // объектом MailManager, если потребуется передать
            // ему какую-то информацию 

            // 'e' определяет дополнительную информацию о событии,
            // которую пожелает предоставить MailManager

            // Обычно расположенный здесь код отправляет
            // сообщение по факсу
            // Тестовая реализация выводит информацию на консоль

            Console.WriteLine("Faxing mail message:");
            Console.WriteLine(" From={0}, To={1}, Subject={2}", e.From, e.To, e.Subject);
        }

        // Этот метод может выполняться для отмены регистрации
        // объекта Fax в качестве получтеля уведомлений о 
        // событии NewMail
        public void Unregister(MailManager mm) 
        {
            // Отменить регистрацию на уведомление о событии 
            // NewMail объекта MailManager
            mm.NewMail -= FaxMsg;
        }
    }


При инициализации нового экземпляра Fax принимает экземпляр типа MailManager и подписывается на его события. 
В исходном коде строка подпискы распишивается компилятором из:
    mm.NewMail += FaxMsg;
в:
    mm.add_NewMail(new EventHandler<NewMailEventArgs>(this.FaxMsg));

Так код подписки создает делегат нашего типа, инкапсулирующий метод FaxMgs типа Fax, а уже после добавляет в вызванную
переменную его же метдом add_NewMail(). Так даже языки, не поддерживающие события напрямую, способны воспроизводить этот код, 
явно вызывая метод add. Так результ не изменится, хотя исходный код будет не столь лаконичным.

Когда же срабатывает событие обьекта MailManager, вызывается метод FaxMsg() обьекта Fax. Этому методу в качестве аргумента
sender передается ссылка на обьект MailManager. sender редко нужен, а применяется если, например, в ответ на уведомление 
о событии Fax потребуется доступ к полям обьекта MailManager. Также в качестве второго аргумента принимается обьект 
NewMailEventArgs, содержащий всю дополнительную информацию, с которой FaxMsg() работает. 

Заметка: подписанные на события типы/обьекты не очищаются сборщиками мусора: не забывайте отписываться! Это так же означает, что
определение метода отписки - обязательна!

Когда же обьекту Fax надо отписаться от уведомлений, он применит свой метод Unregister, где уже с помощью перегруженного 
оператора -= и анологично преобразуется компилятором:
    mm.remove_NewMail(new EventHandler<NewMailEventArgs>(FaxMsg));

Подписываться/отписываться можно только операторами, использование соответствующих методов напрямую генерирует ошибку
(оператор или метод доступа нельзя вызывать явно)