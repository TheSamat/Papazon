В MailManager есть поле обьявления события:
    public event EventHandler<NewMailEventArgs> NewMail;

При комиляции компилятор определяет 3 конструкции из него:

1. ЗАКРЫТОЕ поле делегата, инициализированное значением null
    private EventHandler<NewMailEventArgs> NewMail = null;

2. ОТКРЫТЫЙ метод add_Xxx() (где Xxx – это имя события, т.е. add_NewMail()):
    // Позволяет объектам регистрироваться в качестве
    // получателей уведомлений о cобытии
    public void add_NewMail(EventHandler<NewMailEventArgs> value) 
    {
        // Цикл и вызов CompareExchange – хитроумный способ
        // добавления делегата способом, безопасным в 
        // отношении потоков
        EventHandler<NewMailEventArgs> prevHandler;
        EventHandler<NewMailEventArgs> newMail = this.NewMail;
        do 
        {
            prevHandler = newMail;
            EventHandler<NewMailEventArgs> newHandler = (EventHandler<NewMailEventArgs>) Delegate.Combine(prevHandler, value);
            newMail = Interlocked.CompareExchange<EventHandler<NewMailEventArgs>>(ref this.NewMail, newHandler, prevHandler);
        } while (newMail != prevHandler);
    }

3. ОТКРЫТЫЙ метод remove_Xxx (где Xxx – это имя события)

    // Позволяет объектам отменять регистрацию в качестве
    // получателей уведомлений о cобытии
    public void remove_NewMail(EventHandler<NewMailEventArgs> value) 
    {
        // Цикл и вызов CompareExchange – хитроумный способ
        // удаления делегата способом, безопасным в 
        // отношении потоков
        EventHandler<NewMailEventArgs> prevHandler;
        EventHandler<NewMailEventArgs> newMail = this.NewMail;
        do 
        {
            prevHandler = newMail;
            EventHandler<NewMailEventArgs> newHandler = (EventHandler<NewMailEventArgs>) Delegate.Remove(prevHandler, value);
            newMail = <EventHandler<NewMailEventArgs>>(ref this.NewMail, newHandler, prevHandler);
        } while (newMail != prevHandler);
    }

В первом пункте просто инициализация поля делегата-события типа-уведомления, содержащего в себе ссылку на заголовок
списка делегатов-подписчиков на событие. При инициализации типа-уведомителя он содержит null - отсутствие подписчков, 
которые прибавляются и убавляются только соответствующими методами в пунктах 2 и 3. Обратите внимание, что поле то закрытое, 
хотя и обьявлено нами как открытое.

Оба метода имеют модификатор доступа, идентичный прописанному в исходном. По сути они аналоги свойств, только имеющий в 
обяpательном порядке оба метода.

Внимание: при удалении любого делегата-метода, не содержащегося в списке не возникнет ни исключения, ни ошибки
Примечание: оба метода работают по паттерну обновления значения способом, безопасным в отношении потоков.