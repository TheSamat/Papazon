Этап 2. Определение члена-события

В C# событие обьявляется ключевым словом event. Каждое событие имеет:
	1) область действия (public в большинстве своем)
	2) тип делегата, указывающий на прототип вызываемого метода/методов
	3) имя

	// Этап 2. Определение члена-события
	public event EventHandler<NewMailEventArgs> NewMail;
	...

здесь:
	2) EventHandler<NewMailEventArgs> - тип события, т.е. все получатели уведомления о событии должны иметь и предостовлять 
	   метод обратного вызова, прототип которого соответствует типу делегата EventHandler<NewMailEventArgs>, 
	3) NewMail - имя

тип делегата должен выглядеть как:
	public delegate void EventHandler<TEventArgs>
	  (Object sender, TEventArgs e) 
	  where TEventArgs: EventArgs;

а прототип метода:
	void MethodName(Object sender, NewMailEventArgs e);


Каждое событие требует в имени делегата и методе обратного вызова параметра, производного от EventArgs, названия "е". А также, 
чтобы метод обратного вызова был void.

Примечание: в методе параметр отпрвитель (sender) имеет object а не тип самого отправителя - MailManager. На это несколько причин:
	1) если будет создан производный класс от MailManager (назовем SmptMailManager), то в методе обратного вызова придется в прототипе 
	   задавать параметр sender тоже на нынешний класс отправитель - SmptMailManager, но это нецелесообразно, ибо наследуется то же
	   событие - NewMail. Так что без разницы какой тип взять в качестве аргумента, он все равно будет приводиться к типу SmptMailManager.
	2) гибкость. Множество классов, поддерживающие событие передающее обьект NewMailEventArgs, могут использовать делегат. Даже 
	   не наследованный от MailManager класс мог бы использовать делегат.



