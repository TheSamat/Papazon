Этап 2. Определение члена-события в типе-уведомителе

В C# событие обьявляется ключевым словом event. Каждое событие имеет:
	1) область действия (public в большинстве своем)
	2) тип делегата, указывающий на прототип вызываемого метода/методов
	3) имя

public event EventHandler<NewMailEventArgs> NewMail;

здесь:
	2) EventHandler<NewMailEventArgs> - тип события, т.е. все получатели уведомления о событии должны иметь и предостовлять 
	   метод обратного вызова, прототип которого соответствует типу делегата EventHandler<NewMailEventArgs>, 
	3) NewMail - имя

тип делегата должен выглядеть как:
	public delegate void EventHandler<TEventArgs> (Object sender, TEventArgs e) where TEventArgs: EventArgs;

а прототип метода обратного вызова:
	void {имя метода}(Object sender, NewMailEventArgs e);

Microsoft рекомедует в делегате и методе обратного вызова определить:
	1) первый параметр, производного Object (обычно называется "sender")
	2) второй параметр, производного от EventArgs (обычно называется "е")
	3) не возвращать ничего (void), чтобы обезопасить работу при многопоточности
	4) не заграмождать ничем иным, а все загружать в тип-уведомление

Примечание: в методе параметр отпрвитель (sender) имеет object а не тип самого отправителя - MailManager. На это несколько причин:
	1) если будет создан производный класс от MailManager (назовем SmptMailManager), то в методе обратного вызова придется в прототипе 
	   задавать параметр sender тоже на нынешний класс отправитель - SmptMailManager, но это нецелесообразно, ибо наследуется то же
	   событие - NewMail. Так что без разницы какой тип взять в качестве аргумента, он все равно будет приводиться к типу SmptMailManager.
	2) гибкость. Множество классов, поддерживающие событие передающее обьект NewMailEventArgs, могут использовать делегат. Даже 
	   не наследованный от MailManager класс мог бы использовать делегат.



