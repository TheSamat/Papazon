В С# с помощью CLR реализуется инкапсуляция, полиморфизм и наследование, но из-за этого возникают проблемы, не очевидные при 
проектировании типов. Даже с вводом механизмов, способствующих решению этих проблем, они сами никуда не делись. Посему Рихтером
рекомендуется максимально обделять в доступе к поведению и к состоянию сущности, типы в наследниках, наследников в возможности изменения 
поведения и состоянию предка.

Для доступа прменяются модификаторы доступа к типам, методам и полям. Причем к обьекту-типу и экземплярам типов применяется разрая 
логика. Например, паттерн "Сингл тон" позволяет делать то же, что и static класс, но благодяря своей природе обьекта, способна 
насделовать/наследоваться, реализовывать интерфейсы и многое другое, посему сингл тон предпочтительней.

Так же приводит способ определения "запечатанного" типа, способный иметь наследников, не способных переопределить поведение и
не имеющих прямого доступа к состоянию предка, но способный получить доступ к поведению предка и его состоянию через его поведение.
Это недоступо в явном виде в C#, для этого необходимо: все поля - private, методы - public sealed override,
кроме Finalise()

