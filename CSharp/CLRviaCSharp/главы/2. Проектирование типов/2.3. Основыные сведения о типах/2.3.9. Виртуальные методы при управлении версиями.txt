Управление версиями - важный аспект компонентного программирования. Сброки со строгими именами и меры гарантирующие привязку 
приложения именно к тем сборкам, с которыми оно было построено и протестировано - не единственные решения проблем с совместимостью 
на уровне исходного кода. В частности - добавление и изменение членов базового типа.

Пусть у нас есть CompanyA, оспроектировавшие тип Phone:


namespace CompanyA {
  public class Phone {
    public void Dial() {
      Console.WriteLine("Phone.Dial");
      // Выполнить действия по набору телефонного номера
    }
  }
}


А также CompanyB, которым необходимо спроектировать производный от типа Phone, BetterPhone, имеющий другую семантику:


namespace CompanyB {
  public class BetterPhone : CompanyA.Phone {
    public void Dial() {
      Console.WriteLine("BetterPhone.Dial");
      EstablishConnection();
      base.Dial();
    }

    protected virtual void EstablishConnection() {
    Console.WriteLine("BetterPhone.EstablishConnection");
    // Выполнить действия по набору телефонного номера
    }
  }
}


Но при компиляции всплывет предупреждение, что BetterPhone.Dial() скрывает одноименный метод в Phone, и не будет уверенности, что
их семантика одинакова. Для решения этого необходимо обьясить компилятору, что эти методы хоть и имеют одинаковые имена, сигнатуру, 
но разные и не связаны. Сделать это можно ключевым словом new: public [new] void Dial(){...}


А вот применение:
public sealed class Program {
  public static void Main() {
    CompanyB.BetterPhone phone = new CompanyB.BetterPhone();
    phone.Dial();
  }
}
//вывод:
BetterPhone.Dial
BetterPhone.EstablishConnection
Phone.Dial


Но вот CompanyA обновила метод Dial и CompanyB решила его использовать заместо своего. Но также CompanyA добавила функционал в виде 
одноименного метода EstablishConnection():

namespace CompanyA {
  public class Phone {
    public void Dial() {
      Console.WriteLine("Phone.Dial");
      EstablishConnection();
      // Выполнить действия по набору телефонного номера
    }

    protected virtual void EstablishConnection() {
      Console.WriteLine("Phone.EstablishConnection");
      // Выполнить действия по установлению соединения
    }
  }
}

При обновлении типа Phone, появились конфликты. Теперь примечание о скрытии будет работать еще и по витруальному методу 
EstablishConnection(), но переопределять его не обязательно:
protected [new] virtual void EstablishConnection() {...}

После этого Main() выдаст:
BetterPhone.Dial
BetterPhone.EstablishConnection
Phone.Dial
Phone.EstablishConnection

Что показывает, что метод Dial определенный в BetterPhone вызывает BetterPhone.EstablishConnection(), а base.Dial() - 
Phone.EstablishConnection(), что и требовалось CompanyB. Если же необходимо, чтобы base.Dial() вызывал их семантику(реализацию), 
то их Dial необходимо удалить, а в их методе EstablishConnection() удалить модификатор new и переопределить метод с помощью 
модификатора override:

namespace CompanyB {
  public class BetterPhone : CompanyA.Phone {
  // Метод Dial удален (так как он наследуется от базового типа)
  // Здесь ключевое слово new удалено, а модификатор virtual заменен
  // на override, чтобы указать, что этот метод связан с методом
  // EstablishConnection из базового типа
    protected override void EstablishConnection() {
      Console.WriteLine("BetterPhone.EstablishConnection");
      // Выполнить действия по установлению соединения
    }
  }
}