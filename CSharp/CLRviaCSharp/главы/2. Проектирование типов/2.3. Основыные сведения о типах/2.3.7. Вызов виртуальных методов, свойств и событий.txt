Свойства и события неявно реализуются методоами.

Методы выполняют действия над типом (статические методы) или экземпляром типа (нестатические). У каждого метода есть имя, сигнатура, 
возвращаемый тип, который может быть пустым (void). В Il коде могут существовать методы с одинаковым именем, сигнатурой и даже 
возвращаемым типом, однако в C# последнее возможно только благодаря операторам преобразования типов.

Виртуальные методы не могут быть статичны, ибо статичные мотоды неявно невиртуальны, ибо не могут быть переопределены.

Для вызова методов у JIT компилятора есть 2 инструкции:
    1) call - для вызова невиртульных, виртуальных и статических методов. Для статических нyжно указать тип, в котором определен метод. 
       Иначе - узакать переменную, ссылающийся на обьект. При чем подразумевая, что переменная не равен null, т.е. тип переменной 
       указывает в каком типе определен метод, но если не найден, то указывается базовый тип.
    2) callvirt для нестатических методов. Нужно указать переменную, ссылающий на обьект. При вызове невиртуальный метод, тип переменной 
       указывает где определен метод. В случае виртуальных CLR определяет настоящий тип обьекта, на которую ссылается переменная и 
       вызывает метод полиморфно. Во время вызова если переменная null, то вызывается исключение. Из-за этого callvirt медленнее call.

Замечание: статистические методы не могут быть переопределены, ибо относятся к классу, а не экземпляру и посему всегда используют call.

Итак. В C# для статистических используется call. Для виртуальных и невиртуальных же callvirt в большинстве случаев, что 
несколько замедляет работу. Даже в тех случаях, когда для метода не важно является ли обьект null или нет, когда необходим 
только тип переменной. Но в C# подобное пресекается для большей безопасности.

Внимание: если метод был определен как невиртуальный, не рекомендуется его делать виртуальным, так как при вызове call, 
неперекомпилированный код может вести себя непредсказуемо. В c# используется cellvirt для почти всех экземплярных методов, 
так что у него с этим проблем нет, но другие языки в зоне риска.

Но иногда cell все же вызывается для экземплярных методов. Например для виртуального переопределенного ToString(), вызывающий
базовую реализацию, которая вызывает себя же:

class A : Object
{
    public override string ToString() 
    {
        return base.ToSting(); 
        // base.ToSting() вызывает virtual Object.ToSting(), она же вызывает override A.ToSting(), если вызывать его через callvirt
        // далее вызвался бы base.ToSting(), который вызывает virtual Object.ToSting() и пошло поехало
    } 
}

Для предотвращения бесконечного цилка и StackOverflow в подобных саморекуирсивных вызовах используется call.

Также cell вызывается для значимых типов базовых типов, поскольку базовые типы запечатаны, что делает невозможным полиморфизм для 
виртуальных методов, а природа значимых типов делает невозможным значение null для переменной.

Кстати, виртуальный вызов виртуального метода значимого типа CLR необходимо получить ссылку на обьект значимого типа, что требует 
упаковки значимого типа.

cell и cellvirt так же скрыто получают первым параметром аргумент this, ссылающийся на обьект с которым производятся действия. 
Так при проектировании типа следует свести к минимуму количество виртуальных методов, на что следует множество причин:
    1) виртуальный метод вызывается медленнее невиртульного
    2) JIT компилятор не может инлайнить (подставлять) виртуальные методы, что замедляет работу
    3) виртуальные методы затрудняют управление версиями компонентов
    4) при определении базового типа при создании полиморфного метода, следует сделать виртуальным только самый сложный метод, 
       оставив остальные невиртуальными. Так еще кстати поможет управлять версиями компонентов, не нарушая работу производных типов

Пример:
public class Set{
  private int m_lenght = 0;
  
  public int Find(Object value){
    return Find(value, 0, m_lenght);
  }

  public int Find(Object value, int startIndex){
    return Find(value, fromIndex, m_lenght);
  }

  public virtual int Find(Object value, int startIndex, end){
    //настоящая реализация, которую можно переопределить
  }
}
