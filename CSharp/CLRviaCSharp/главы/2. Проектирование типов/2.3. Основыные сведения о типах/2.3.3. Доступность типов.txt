Доступность к типам обрабатывается еще на этапе компиляции, сам его процесс описан в CLR, в котором врочем есть 
неиспользованные модификаторы доступа в C#: родовой и сборочный.

Даже если C# компилятор не найдет ошибки доступа, то JIT сам справится с этим.

Также CLR требует, что члены интерфейсов были открытыми, что отображается на невозможности явного указывания модификаторов доступа.

Так же переопределение члена базового типа в C#, требует одинакового модификатора доступа, но CLR же на это плевать, если 
открытость не больше. Сделано это из-за возможности обхода с помощью метода базового типа через приведение к нему. 