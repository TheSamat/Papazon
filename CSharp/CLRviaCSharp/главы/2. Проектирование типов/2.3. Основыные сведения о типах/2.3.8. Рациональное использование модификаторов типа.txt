В проекте  используются типы, определенные в многочисленных сборках, созданных ращличными компаниями. 

Итого: полное отсутствие контроля над используемыми компонентами и типами, исходный код которых недоступен, если не неизвестен 
даже исходный язык и при всем при том обновляется в произвольное время. Посему разработчики используемого кода сбоки и разрабатываемого 
должны доверять друг другу, и модификаторы доступа и видимости в этом способствуют.

По умолчанию в C# все типы незапечатаны(sealed) по умолчанию, но запечатанность типов имеет плюсы:
	1) Управление версиями. Если класс изначально был запечатан, то его можно сделать незапечатанным, не нарушая совместимости, а вот 
	   обратное уже невозможно, ибо нарушило бы работу всех производных классов. Кроме того, для незапечатанных (в незапечатанных типах) 
	   виртуальных методов необходимо сохранять порядок вызова виртуальных методов в следующих версиях для совместимости с 
	   производными типами.
	2) Производительность. Невиртуальные методы вызываются быстрее виртуальных. Однако вызов виртуального метода в запечатанном типе 
	   вызывается невиртуально.
	3) Безопасность и предсказуемость. Состояние класса должно быть надежно защищено. Производный класс может воспользоваться 
	   незащищенными полями или методами базового класса, изменяющие незащищенные поля, переопределять виртуальные методы. 
	   Так делая метод, свойство или событие витруальным, базовый класс уступает часть контроля производному, что может вызвать 
	   непредсказуемое поведение или проблемы с безопасностью.

Если же пользователям типа понадобится допольнительные поля, другая информация о состоянии типа или допольнительные методы, то CLR
ничем не может помочь, однако C# позволяет имитировать расширение типа методами расширения, а состояния обьекта - классом 
ConditionalWeakTable.

Для организации кода же рекомендуется Ритчердом:
	1) Если тип не будет наследоваться, обьявлять его закрытым. Если же тип будет наследоваться, но не будет специализироваться, 
	   необходимо переопределить и запечатать все витруальные методы, которые наследует класс. Если не предпологается его 
	   использование другими сборками - обьявлять внутренним. 
	2) Все поля класса - закрытые. В дополнение, в C# так сделано по умолчанию. Изменение состояния типа вне типа чревато
	   неопределенностью, а отслеживание обращений к полю даже в одной сборке трудно, особенно при управлении версиями.
	3) Методы, свойства и события - закрытые и невиртуальные. Здесь тоже в C# так по умолчанию. Для случаев использования метода, 
	   необходимо public, а protected или iternal лучше не использовать, но в то же время не делать их виртуальными, если того 
	   не требуется. Даже закрытый виртуальный метод может создасть неопределенность.
	4) Если реализация алгоритма усложнена, следует определить вспомогательные типы, инкапсулирующие часть функциональности. 
	   В случае, если вспомогательные типы используются только в единственном типе (называемый супертипом в паттернах или 
	   в контексте алгоритмов и архитектуры), то следует сделать их вложенными, что позволит ссылаться на них черех супертип, 
	   а им  - обращаться к защищенным членам супертипа. Сами же вложенные типы не должны быть открытыми. 