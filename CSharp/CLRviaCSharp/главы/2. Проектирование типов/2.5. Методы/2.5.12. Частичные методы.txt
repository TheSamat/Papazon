В случае, когда используется служебная программа, определяющая типы на C# и необходимо настроить поведение типа (методы определить),
но при том тогда, когда методов еще нет. Сгенерированный код обычно в классе настороит виртуальные методы, которые просто 
возвращают управление, а в наследнике настроит его поведение:

    // Сгенерированный код в некотором файле с исходным кодом:
    internal class Base 
    {
      private String m_name;
      // Вызывается перед изменением поля m_name
      protected virtual void OnNameChanging(String value) { }
      public String Name 
      {
        get { return m_name; }
        set 
        {
          // Информирует класс о возможных изменениях
          OnNameChanging(value.ToUpper());
          m_name = value; // Изменение поля
        }
      }
    }

    // Написанный программистом код из другого файла
    internal class Derived : Base 
    {
      protected override void OnNameChanging(string value) 
      {
        if (String.IsNullOrEmpty(value))
        throw new ArgumentNullException("value");
      }
    }

Это не эффективно (а думать надо было, прежде чем коду свою работу предоставлять) и не работает в случае, когда наш тип запечатан,
он значимый тип или методы статичны.

А частичные методы это улучшают и требуют простой постановки ключевого слова partial:

    // Сгенерированный при помощи инструмента программный код
    internal sealed partial class Base {
        private String m_name;
        // Это объявление с определением частичного метода
        // вызывается перед изменением поля m_name
        partial void OnNameChanging(String value);
        public String Name 
        {
            get { return m_name; }
            set 
            {
                // Информирование класса о потенциальном изменении
                OnNameChanging(value.ToUpper());
                m_name = value; // Изменение поля
            }
        }
    }

    // Написанный программистом код, содержащийся в другом файле
    internal sealed partial class Base {
      // Это объявление с реализацией частичного метода
      // вызывается перед тем, как будет изменено поле m_name
      partial void OnNameChanging(String value) {
        if (String.IsNullOrEmpty(value))
        throw new ArgumentNullException("value");
      }
    }

Теперь класс запечатан (хотя это и не обязательно). В действительности, класс мог бы быть статическим классом или даже значимым типом. 

Код, сгенерированный программой, и код, написанный программистом, на самом деле являются двумя частичными определениями, которые 
в конце концов образуют одно определение типа. Код, сгенерированный программой, представляет собой объявление частичного метода.
Этот метод помечен ключевым словом partial и не имеет тела. Код, написанный программистом, реализует объявление частичного метода.
Этот метод также помечен ключевым словом partial и тоже не имеет тела.

