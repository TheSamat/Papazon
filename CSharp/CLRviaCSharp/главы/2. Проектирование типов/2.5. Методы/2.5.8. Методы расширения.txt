Механизм расширения позволяет определять статический метод, вызываемый посредством синтаксиса экземплярного метода (т.е. не работает 
для статистических классов) вне модуля обьявления класса, действуя на уровне пространства имен. 

Ознакомимся на примере: Мы хом работать с StringBuider, ибо он предпочтительней String из-за своей изменяемости, но так же у него
уменьшенный функционал. И нам надо ввести аналог метода IndexOf():

    public static class StringBuilderExtensions
    {
      public static Int32 IndexOf(StringBuilder sb, Char value)
      {
        for (Int32 index = 0; index < sb.Length; index++)
        if (sb[index] == value) return index;

        return -1;
      }
    }

    И его применение в Main():

    StringBuilder sb = new StringBuilder("Hello. My name is Jeff.");
    Int32 index = StringBuilderExtensions.IndexOf(sb.Replace('.', '!'), '!');

Но здесь возникают 2 проблемы: необходимость понимания/знание в проекте класса StringBuilderExtensions и сложность 
понимания/чтения/сопровождения кода из-за его структуры и грамоздкости. А реализация:

    sb.Replace('.', '!');
    Int32 index = StringBuilderExtensions.IndexOf(sb, '!');

Создаст 3ю проблему - понимание логики кода из-за сложности понимания связанности Extensions с StringBuilder. А если бы мы использовали 
методы расширения, то у нас бы развязались руки:

    Int32 index = sb.Replace('.', '!').IndexOf('!');

А для этого всего-то и надо в параметрах метода использовать ключевое слово this перед нашим StringBuilder (this должен стоять перед
первым аргументом и метод расширения будет относиться к обьектам типа этого аргумента):

    public static class StringBuilderExtensions {
      public static Int32 IndexOf(this StringBuilder sb, Char value) {
        for (Int32 index = 0; index < sb.Length; index++)
        if (sb[index] == value) return index;

        return -1;
      }
    }

Итак, компилятор при выполнении метода Main() начнет искать метод IndexOf() в классе StringBuilder и всех его базовых классах.
Но поскольку такого метода не существует, он начнет искать подобный статистический метод в статистических классах с первым параметром
с типом, используемый в методе и ключевым словом this.

Узнать, как компилятор узнает о методах расширения легко - через IntelliSense, котрое показывает список всех доступных методов и 
методов расширения, когда в VisualStudio выбираешь допустимые методы переменной, что очень удобно, когда другие программисты имеют дело
с расширениями, ибо методы расширения там тоже отмечены.