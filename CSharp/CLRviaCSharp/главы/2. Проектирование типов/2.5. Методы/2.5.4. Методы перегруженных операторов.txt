В некоторых языках тип может опеределять, как операторы должны работать с его экземплярами. Например, string, Decimal DateTime 
используют перегрузку операторов == и !=. 

ClR ничего не известно о перегрузке операторов, ибо даже не знает операторов, так как генерируемый код определяется языком 
программирования и CLR видит их как методы. Например, видя оператор + между двумя числами, C# компилятор генерирует код, 
выполняющий сложение 2 чисел. CLR хоть ничего о операторах не известно, она может указывать, как языки программирования должны 
предоставлять доступ к перегруженным операторам.

От языка зависит наличие поддержки перегруженных операторов и их синтаксис, а их реализация генерируется компилятором. Спецификация 
CLR требует, чтобы перегруженные операторы были открытыми и статическими. C# дополнительно требует, чтобы у операторного метода тип 
хотя бы одного параметра или возвращаемого значения совпадал с типом, в котором переоределен операторный метод. Пример:

    public sealed class Complex 
    {
      public static Complex operator+(Complex c1, Complex c2)
      {
        ...
      }
    }

Компилятор генерирует определение метода и устанавливает в методанных определение этого метода с флагом specialname, говорящий о том,
что это особый метод. Когда C# компилятор видит оператор +, он исследует типы его операндов. При этом он ищет метод оператора с 
флажком specialname, параметры которого совместимы с типами операндов и при нахождении генерирует его код. При не нахождении ни 
одного метода оператора, вызывается ошибка компиляции. 

Так же типы примитивных типов не имеют определений операторов - компиляторы уже знают о них. Это сделано для оптимизации, предотвратив
обращение к типам, т.е. если язык, на котором вы пишете, не поддерживает какой-либо из фундаментальных типов FCL, вы не сможете 
выполнять действия над экземплярами этого типа.

В CLR есть только поля и методы, так что перенос перегруженных операторов с CLR в другой язык, не поддерживающий перегруженные операторы,
сможет их вызывать через эти методы. Но наоборот, если язык, поддерживающий перегрузку методов, но не поддерживающий CLR захочет перенести
свои перегруженные операторы, даже соответствующие по определению не смогут поддерживаться из-за отсутствия в методанных флага specialname.

Так же Microsoft рекомендует определять к перегруженным операторам еще и методы с дружественными именами, использующие реализацию
перегруженных методов:

public sealed class Complex {
    public static Complex operator+(Complex c1, Complex c2) { ... }
    public static Complex Add(Complex c1, Complex c2) { return(c1 + c2); }
}

Для Рихтера подобное странно и использование методанных - тот еще костыль.