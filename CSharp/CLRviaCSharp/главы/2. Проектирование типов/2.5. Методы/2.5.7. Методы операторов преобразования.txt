Когда необходимо преобразовать примитивные типы, компилятор способен без посторонней помощи генерировать код преобразования. В ином 
случае компилятор генерируемым кодом заставляет CLR выполнить преобразование (приведение типов). В этом случае CLR просто проверяет, 
совпадает ли тип исходного обьекта с целевым типом (или является производным от целевого). 

Однако в случае преобразования совершенно не связанных иеархией наследования типов, в исходном типе необходимо определить оператор 
преобразования, для которого должны определяться 2 метода:
    1) открытый конструктор, принимающие в качестве единственного параметра экземпляр целевого типа. 
    2) открытый экземплярный метод ToXxx(), не принимающий параметров (как ToString()). 

Каждый подобный метод преобразует экземпляр типа, в котором определен этот метод, в экземпляр типа Xxx. Например:

    public sealed class Rational {
        // Создает Rational из Int32
        public Rational(Int32 num) { ... }
        // Создает Rational из Single
        public Rational(Single num) { ... }

        // Преобразует Rational в Int32
        public Int32 ToInt32() { ... }
        // Преобразует Rational в Single
        public Single ToSingle() { ... }
    }

Вызывая эти конструкторы и методы можно преобразовывать обьекты типа Int32 и Single в Rational и обратно на всех языках. Подобные 
методы преобразования очень удобны, но для вызова перегруженного оператора преобразования, на подобии примитивных типов необходимо 
определить еще по паре методов с модификатором implict/explict:

    public sealed class Rational
    {
        // Создает Rational из Int32
        public Rational(Int32 num) { ... }
     
        // Создает Rational из Single
        public Rational(Single num) { ... }

        // Преобразует Rational в Int32
        public Int32 ToInt32() { ... }
        
        // Преобразует Rational в Single
        public Single ToSingle() { ... }
        
        // Неявно создает Rational из Int32 и возвращает полученный объект
        public static implicit operator Rational(Int32 num) 
        {
            return new Rational(num); 
        }
        
        // Неявно создает Rational из Single и возвращает полученный объект
        public static implicit operator Rational(Single num) 
        {
            return new Rational(num); 
        }
        
        // Явно возвращает объект типа Int32, полученный из Rational
        public static explicit operator Int32(Rational r) 
        {
            return r.ToInt32(); 
        }
        
        // Явно возвращает объект типа Single, полученный из Rational
        public static explicit operator Single(Rational r) 
        {
            return r.ToSingle();
        }
    }

При определении методов преобразования следует указать должен ли компилятор генерировать код для их неявного вызова автоматически 
или лишь при наличии явного указания. implict указывает C# компилятору, что наличие в исходном коде явного приведения не обязательна, 
а explict - наоборот только при явном. operator же указывает, что метод - метод преобразования. После operator указывается целевой тип, 
а в скобках - исходный:

Rational r1 = 5; // Неявное приведение Int32 к Rational
Rational r2 = 2.5F; // Неявное приведение Single к Rational
Int32 x = (Int32) r1; // Явное приведение Rational к Int32
Single s = (Single) r2; // Явное приведение Rational к Single

Под капотом же компилятор C# обнаруживает в исходном коде операцию приведения и генерирует IL код, использующий методы операторов 
преобразования, опеределенные в Rational:

public static Rational op_Implicit(Int32 num)
public static Rational op_Implicit(Single num)
public static Int32 op_Explicit(Rational r)
public static Single op_Explicit(Rational r)

Примечание: C++, C#, Visual Basic и Java не позволяют определять методы с разницей лишь в возвращаемых значениях, но IL же может. 
Правда злоупотребрять подобным не стоит, ибо подобное недоступно для совместимых с IL языком языков, отдавая такую возможность лишь 
компилятору.

Оператор неявного приведения стоит определять только тогда, когда из-за этого не теряются точность или данные. Если же преобразование
завершится неудачно, то вызовется исключение. Обнаружив код, в котором вместо ожидаемого типа используется другой тип, компилятор будет
искать метод неявного преобразования, при нахождении которого станет использоваться. В случае нахождения явного приведения - то же самое
для явного преобразования. В случае, если не найден подобный метод вызовется ошибка компиляции.

Примечание: С# генерирует код вызова операторов неявного преобразования в случае, когда используется выражение приведения типов. 
Однако операторы неявного преобразования никогда не вызываются, если используется оператор as или is.

Методы расширения для преобразования типов не могут иметь доступа к приватным полям обьекта, в отличии от метода типа или операторов. 
Так же методы расширения низкоприоритентны и не будут вызваны при существовании схожего метода, а так же неоптимизированы из-за своей 
природы.