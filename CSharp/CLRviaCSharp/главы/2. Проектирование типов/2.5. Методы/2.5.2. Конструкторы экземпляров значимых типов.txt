В CLR конструкторы значимых типов работают иначе. CLR всегда разрешает создание экземпляров значимых типов, поэтому конструктор 
значимого типа можно не определять. C# так же не создает конструктор по умолчанию без параметров.

Если создается экземпляр структуры(значимый тип), у которого нет конструктора, то вызовется конструктор, автоматически сгенерированный 
компилятором. Перед вызовом выделяется память для каждого поля, а они сами инициализируются 0/null; так же не будут вызваны конструкторы 
для каждого экземпляра значимого типа, содержащийся в обьекте ссылочного типа.

Хоть конструкторы можно задавать, но они будут вызываться только если те будут вызываться явно. Однако C# не позволит создавать 
конструкторы без параметров. Если конструктор определить нельзя, компилятор никогда не будет автоматически генерировать код, вызывающий 
конструктор. Но CLR же допускает подобное.

Так же в значимый тип нельзя подставлять инициализацию экземплярных полей с значениями по умолчанию:

    internal struct SomeValType {
      //нельзя подставлять инициализацию экземплярных полей
      private Int32 m_x = 5;
    }

А еще каждый конструктор должен инициализировать все поля значимого типа:

    internal struct SomeValType {
      private Int32 m_x, m_y;
      // C# допускает наличие у значимых типов конструкторов с параметрами
      public SomeValType(Int32 x) {
          m_x = x;
          // Обратите внимание: поле m_y здесь не инициализируется
      }
    }

это вызовет ошибку, но можно вначале инициализировать все поля и только после присваивать значения:

    public SomeValType(Int32 x) {
        // Выглядит необычно, но компилируется прекрасно, и все поля инициализируются значениями 0 или null
        // Для ссылочных подобное не сработает
        this = new SomeValType();
        m_x = x; // Присваивает m_x значение x
        // Обратите внимание, что поле m_y было инициализировано нулем
    }

Однако для статических полей все прекрасно работает, ибо статический конструктор типа имеет общий функционал вне зависимости от того 
является ли тип значимым или ссылочным.

Class<T> {static int a;}

A<int>.a=5; 
A<int32>.a=5;
A<double>.a=30;