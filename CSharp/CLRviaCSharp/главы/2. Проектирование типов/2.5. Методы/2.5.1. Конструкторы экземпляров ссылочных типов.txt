Конструкторы - специальные методы, позволяющие корректно инициализировать новые экземпляры типов. При создании экземпляра обьекта 
ссылочного типа (классов) выделяется память под поля экземпляра и инициализируются служебные поля (указатель на обьект-тип и 
индекс блока синхронизации), а после и сам конструктор экземпляров, устанавливающий состояние нового обьекта.

При конструировании обьекта ссылочного типа выделяемая для него память всегда обнуляется до вызова конструктора экземпляра типа. 
Любые поля, не задаваемые конструктором явно, гарантированно содержат либо 0 для значимых примитивных, либо null для ссылочных.

Конструкторы не наследуются, т.е. являются неявно невиртуальными, что запрещает ставить модификаторы virtual, new, override, sealed и 
abstract. Если же не определять явно в классе хотя бы один конструктор в C# автоматом создастся конструктор по умолчанию (без параметров), 
реализующий конструктор без параметров базового класса. 

Для абстактных же к конструктору по умалчанию довавляется модификатор protected. Если в базовом классе нет конструктора без параметров, 
производный класс должен явно вызывать конструктор базового класса, иначе - ошибка компиляции. Для статических классов (неявно 
запечатанных и абстрактных) компилятор не создает конструктор по умолчанию.

В типе может определяться несколько конструкторов, при этом сигнатуры и уровни доступа обязательно должны отличаться (имя то у них одно). 
Также стоит помнить, что любой конструктор неявно вызывает конструктор базового типа, он же своего и т.д. Так вызывается конструктор 
System.Object() при создании любого экземпляра класса, врочем он ничего не делает, просто возвращая управление. Из-за этого, кстати, у 
наследника конструктор обязан соответствовать хотя бы одному конструктору предка по сигнатуре.

Конструкторы экземпляров у статичных типов не создается.

Инициализация обычных полей типа вначале по дефолтному значению (0/null), а значение по умолчанию будет не присваивать им инове значение, а
дополнять начало каждого конструктора, т.е. это:

    class A
    {
        int a;
        int b;
        int c = 10;
        int d = 10;

        public A() : this(0) { }
        public A(int a) : this(a, 10) { }
        public A(int a, int b)
        {
            this.a = a;
            this.b = b;
        }
        public override string ToString()
        {
            return $"{this.a}, {this.b}, {this.c}, {this.d}";
        }
    }

преобразуется компилятором в:

class A
{
    int a;
    int b;
    int c;
    int d;

    public A() : this(0) 
    {
        c = 10;
        d = 10;
    }
    public A(int a) : this(a, 10) 
    {
        c = 10;
        d = 10;
    }
    public A(int a, int b)
    {
        c = 10;
        d = 10;
        this.a = a;
        this.b = b;
    }
    public override string ToString()
    {
        return $"{this.a}, {this.b}, {this.c}, {this.d}";
    }
}

Поэтому не рекомендуется создавать поля с значениями по умолчанию в случае определения хотя бы одного конструктора. Вместо этого лучше
инициализировать их в конструкторе без параметров:

class A
{
    int a;
    int b;
    int c;
    int d;

    public A() : this(0) 
    {
        c = 10;
        d = 10;
    }
    public A(int a) : this(a, 10) {} 
    public A(int a, int b)
    {
        this.a = a;
        this.b = b;
    }
    public override string ToString()
    {
        return $"{this.a}, {this.b}, {this.c}, {this.d}";
    }
}