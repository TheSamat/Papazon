Конструкторы типов, статические конструктооры, конструкторы классов и инициализаторы классов - одно и то же. Конструкторы можно
применять и к интерфейсам (не в C#). По умолчанию у типа нет конструктора типа, а так же не может быть больше одного и конструктор
не должен иметь параметров:

    internal sealed class SomeRefType {
      static SomeRefType() {
        // Исполняется при первом обращении к ссылочному типу SomeRefType
      }
    }

    internal struct SomeValType {
      // C# на самом деле допускает определять для значимых типов
      // конструкторы без параметров
     static SomeValType() {
        // Исполняется при первом обращении к значимому типу SomeValType
      }
    }

Конструкторы типов отличаются лишь static модификатором, отсутствием параметров. Так же они тоже неявно закрыты, из-за чего модификаторы
свящанные с этим вызовят ошибку компиляции.

ВНИМАНИЕ: Хотя конструктор типа можно определить в значимом типе, далать это не надо, ибо иногда CLR может не вызывать статический 
конструктор значимого типа.

Конструктор типа вызывается по особенному. При компиляции JIT-компилятор ищет типы, на которые ссылается код. В этих типах он проверяет
был ли упомянут конструктор типа в текущем домене приложения. После сам решает вызывать конструктор типа до выполнения фрагмента кода или 
же во время выполнения. Так или иначе после вызова конструктора типа после вызываться уже не будет. 

Так же есть ньюанс в способе вызова конструктора типа, влияющий на его исполнение:

    public class Program
    {
        private static void Main(string[] args)
        {
            long count = 100000000;
            for (int i = 0; i < 10; i++)
            {
                CheckTime(count);
            }

        }
        private static void CheckTime(long count)
        {
            var sw = new Stopwatch();
            sw.Start();
            for (int i = 0; i < count; i++)
            {
                BeforeFieldInit.Value = 1;  // конструктор типа вызывается в начале выполнения метода
            }
            TimeSpan a = sw.Elapsed;
            Console.WriteLine($"Test BeforeFieldInit:   {sw.Elapsed}");

            sw = new Stopwatch();
            sw.Start();
            for (int i = 0; i < count; i++)
            {
                InCtorFieldInit.Value = 1;  // конструктор вызывается в цикле только раз, но проверяет в 
                                            // каждой итерации на обращения из других потоков
            }
            TimeSpan b = sw.Elapsed;
            Console.WriteLine($"Test InCtorFieldInit:   {sw.Elapsed}");
            Console.WriteLine($"                        {b-a}");
        }
    }
    public sealed class BeforeFieldInit
    {
        public static int Value = 123;  // авто конструктор, в нем нет логики, поэтому вызывается вначале кода
    }
    public sealed class InCtorFieldInit
    {
        public static int Value;
        static InCtorFieldInit()        // свой конструктор, может иметь дополнительную логику, посему должен быть 
                                        // использован во время выполнения программы
        {
            Value = 123;
        }
    }

Итого вызов:
    Test BeforeFieldInit:   00:00:00.1707501
    Test InCtorFieldInit:   00:00:00.2516801
                            00:00:00.0809300
    Test BeforeFieldInit:   00:00:00.1568739
    Test InCtorFieldInit:   00:00:00.3596720
                            00:00:00.2027979
    Test BeforeFieldInit:   00:00:00.3636847
    Test InCtorFieldInit:   00:00:00.5760678
                            00:00:00.2123834
    Test BeforeFieldInit:   00:00:00.3354706
    Test InCtorFieldInit:   00:00:00.6431890
                            00:00:00.3077169
    Test BeforeFieldInit:   00:00:00.3940037
    Test InCtorFieldInit:   00:00:00.6541300
                            00:00:00.2601264
    Test BeforeFieldInit:   00:00:00.3630681
    Test InCtorFieldInit:   00:00:00.2847529
                            -00:00:00.0783152
    Test BeforeFieldInit:   00:00:00.1716949
    Test InCtorFieldInit:   00:00:00.2747681
                            00:00:00.1030731
    Test BeforeFieldInit:   00:00:00.2037400
    Test InCtorFieldInit:   00:00:00.2750687
                            00:00:00.0713287
    Test BeforeFieldInit:   00:00:00.1681719
    Test InCtorFieldInit:   00:00:00.2786242
                            00:00:00.1104521
    Test BeforeFieldInit:   00:00:00.1995969
    Test InCtorFieldInit:   00:00:00.2533488
                            00:00:00.0537521

В случае, если сразу несколько потоков вызовут конструктор, то CLR гарантирует, что код конструктора выполнится единожды для всех потоков.
Для этого при вызове конструктора вызывающий поток в рамках синхронизации потоков получит исключающую блокировку, т.е. если другой поток 
в это время попробует вызвать конструктор, то он заблокируется. Первый поток после вызова конструктора разблокируются остальные потоки, 
которые проверят выполнение конструктора и запомнят, что он выполнен, вернут управление из конструктора/метода и в следующий вызов
конструктора не будут выполнять код снова. Кстати, из-за этого конструктор типа идеально подходит для инициализаци всех singleton обьектов, 
необходимых типу.

Но даже для одного потока бывают сложные ситуации: конструктор типа ClassA, ссылающийся на ClassB, а конструктор типа ClassB ссылается 
на ClassA. Поскольку CLR будет выполнят код каждого конструктора лишь раз, то он застопорится при выполнение конструктора ClassA и 
начнет вызывать конструктор типа ClassB. Если же подобным образом вызовется  необработываемое исключение, CLR посчитает тип непригодным
для использования и при попытке обращения к любому полю/методу типа вызовет исключение. 

Заметка: не стоит писать код, требующий вызовов типов в определенном порядке.

Код конструктора может обращаться только к статичным полям типа. Но при этом C# не позволяет в значимых типах использовать синтаксис
инициализации полей на месте, но разрешает это в статических полях.

Так же конструктор типа не должен вызывать конструктор базового типа. Этот вызов необязателен, ибо ни одно статистическое поле типа не
используется совместно с базовым типом и не наследуется от него. В Java же предполагается, что при обращении к типу будет вызван его 
конструктор, а также конструкторы всех его базовых типов. Интерфейсы, реализованные этим типом тоже вызывают свои конструкторы. 
CLR может имитировать подобную семантику через метод System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor().

    internal sealed class SomeType {
      private static Int32 s_x = 5;
      static SomeTypeQ {
        s_x = 10;
      }
    }

При выполнении этого кода создастся единственный метод-конструктор типа, инициализирующий статистические поля типа вначале по значениям 
инициализированным на месте полям, а после по явной реализации конструктора, т.е. вначале он инициплизирует s_x значением 5, после - 10;

ВНИМАНИЕ: выгрузка типа осуществляется только при закрытии домена приложений. При закрытии домена приложений обьекты, 
идентифицирующие типы, становятся недоступны и убираются сбощиками мусора. Метод Finalize, запускаемый перед выгрузкой, же не 
может быть статичным, т.е. использоваться для типа, но CLR же имеет альтернативу - метод обратного вызова для события 
System.AppDomain.DomainUnload
