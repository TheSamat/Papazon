Поскольку метод расширения является статистическим, то CLR не генерирует код проверки на null:

    StringBuilder sb = null;

    // Вызов метода выражения: исключение NullReferenceException // НЕ БУДЕТ выдано при вызове статистического IndexOf
    // Исключение NullReferenceException будет вброшено внутри
    // цикла IndexOf
    sb.IndexOf('X');

    // Вызов экземплярного метода: исключение
    // NullReferenceException БУДЕТ вброшено при вызове Replace
    sb.Replace('.', '!');

А еще методы расширения могут быть определены и для интерфейсных типов, в частности для всех выражений, результат которого возвращает тип, 
реализующий тип Enumerable:

    public static void ShowItems<T>(this IEnumerable collection)
    {
      foreach (var item in collection)
        Console.WriteLine(item);
    }

    public static void Main() {
      // Показывает каждый символ в каждой строке консоли
      "Grant".ShowItems();

      // Показывает каждую строку в каждой строке консоли
      new[] { "Jeff", "Kristin" }.ShowItems();

      // Показывает каждый Int32 в каждой строчке консоли.
      new List<Int32>() { 1, 2, 3 }.ShowItems();
    }


ВНИМАНИЕ: Методы расширения - краеугольный камень для Language Integrated Query (LINQ). Эта технология по полной пользуется всеми 
преимуществами LINQ.

Методы расширения можно определить и для типов-делегатов:

    public static void InvokeAndCatch<TException>(this Action<Object> d, Object o) where TException : Exception
    {
      try { d(o); }
      catch (TException) { }
    }

    ...
    Action<Object> action = o => Console.WriteLine(o.GetType());
    // Выдает NullReferenceException

    action.InvokeAndCatch<NullReferenceException>(null);
    // Поглощает NullReferenceException


Кроме того, можно добавлять методы расширения к перечисляемым типам. И еще можно создавать делегаты, ссылающиеся на метод расширения:

    public static void Main()
    {
      // Cоздание делегата Action, ссылающегося на статический
      // метод расширения ShowItems; первый аргумент
      // инициализируется ссылкой на строку "Jeff"
      Action a = "Jeff".ShowItems;

      // Вызов делегата, вызывающего ShowItems и передающего
      // ссылку на строку "Jeff"
      a();
    }

В коде C# компилятор создает делегат Action, конструктор передается в метод ShowItems() и ссылка на обьект, передающийся как скрытый 
параметр. Обычно же при создании делегата, ссылающегося на статический метод, обьектная ссылка равна null, ибо статистический метод
не имеет подобного параметра. Однако при ссылании на метод расширения все работает как показано выше.