CLR создает внутреннюю структуру (обьект-тип) данных для каждого типа, применяемого в приложении, называемыми 
обьектами-типами (type objects). Обобщенный тип тоже тип и для него тоже создается обьект-тип, называемый открытым типом.
Открытые типы и интерфейсы не могут иметь экземпляры.

Закрытые типы - могут иметь наследников, но только если они не запечатаны. К ним относятся все необобщенные типы.

Обобщенным типам можно определить набор обобщенных аргументов типа, создавая новый обьект-тип. Если для конкретного 
обобщенного типа переданы все аргументы в виде закрытых типов, то этот тип становится закрытым и уже может иметь экземпляры.
Если же, определены не все обобщенные аргументы, создается обьект-тип открытого типа, экземпляры которого создавать нельзя:

    // Частично определенный открытый тип
    internal sealed class DictionaryStringKey<TValue> :
        Dictionary<String, TValue> {
    }

    public static class Program 
    {
        public static void Main() 
        {
            Object o = null;
            // Dictionary<,> — открытый тип с двумя параметрами типа
            Type t = typeof(Dictionary<,>);
  
            // Попытка создания экземпляра этого типа (неудачная)
            o = CreateInstance(t);
            Console.WriteLine();
  
            // DictionaryStringKey<> — открытый тип с 
            // одним параметром типа
            t = typeof(DictionaryStringKey<>);
            // Попытка создания экземпляра этого типа (неудачная)
            o = CreateInstance(t);
            Console.WriteLine();

            // DictionaryStringKey<Guid> — это закрытый тип
            t = typeof(DictionaryStringKey<Guid>);
            // Попытка создания экземпляра этого типа (удачная)
            o = CreateInstance(t);
            // Проверка успешности попытки
            Console.WriteLine("Object type=" + o.GetType());
        }

        private static Object CreateInstance(Type t) 
        {
            Object o = null;
            try 
            {
                o = Activator.CreateInstance(t);
                Console.Write("Created instance of {0}", 
                t.ToString());
            }
            catch (ArgumentException e) 
            {
                Console.WriteLine(e.Message);
            }
            return o;
        }
    } 

И вывод программы:

    Cannot create an instance of System.Collections.Generic.
    Dictionary`2[TKey,TValue] because Type.ContainsGenericParameters is true.

    Cannot create an instance of DictionaryStringKey`1[TValue] because
    Type.ContainsGenericParameters is true.

    Created instance of DictionaryStringKey`1[System.Guid]
    Object type=DictionaryStringKey`1[System.Guid]


При первом варианте вылетает исключение ArgumentException, из-за содержания в себе обобщенных параметров 
(они не были заменены другими)

Имена обобщенных типов состоят из имени самого типа, оканчивающейся на (`), за ней арность (arity) - число 
необходимых закрытых параметров. 

Если вспомнить, то у каждого обьекта-типа есть статичные поля и методы. Определенные у List<T> статичные поля не будут 
пользоваться совместно с List<String> или List<int>, ибо у них есть свои, т.е. у каждого закрытого типа свои поля и методы. 
Если у обобщенного открытого типа определен статистический конструктор, то он выполниться один раз для каждого закрытого типа.