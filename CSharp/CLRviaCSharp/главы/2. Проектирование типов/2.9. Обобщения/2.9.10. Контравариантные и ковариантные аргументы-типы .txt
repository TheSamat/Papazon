У каждого типа есть свойство, влиящее на возможность его преобразования - вариантности:
	1)	Инвариантность		-	тип параментра обобщенного типа не может быть преобзован. Используется по умолчанию
	2)	Ковариантность		-	тип может быть преобразован к предку, т.е. к более абстрактному и только
		в выходной позиции, например return с оператором out
	3)	Контровариантность	-	тип может быть преобразован к наследнику, т.е. к более конкретному и только 
		в входной позиции, например аргумент метода с оператором in 

	public delegate TResult Func<in T, out TResult>(T arg);	// Т - контровариантен, TResult - ковариантен
	...
	Func<Object, ArgumentException> fn1 = null;
	Func<String, Exception> fn2 = fn1; // Явного приведения типа не требуется
	Exception e = fn2("");	// спокойно компилируется, во время выполнения сохраняется безопасность типов

Но возможности вариантности ограничены возможностью ссылочной преобразования типов, т.е. вариантность, кроме инвариантной 
у значимых типов априори невозможна из-за упаковки:
	void ProcessCollection(IEnumerable<Object> collection) { }
    ProcessCollection(new List<DateTime>());	// ошибка, нельзя прямо переопределить тип, даже при прямой наследованности
Но можно применять дополнительное обобщение, чтобы обойти это ограничение:
	void ProcessCollection<T>(IEnumerable<T> collection) { ... }
	ProcessCollection(new List<DateTime>());	// все ок

Так же вариантность невозможна при использовании модификаторов ref и out:
	delegate void SomeDelegate<in T>(ref T t);	// несоответствие вариантностей
	delegate void SomeDelegate<T>(ref T t);		// все ок, тип-параметр аргумента "t" - контрвариантен

Рекомендуется при определении вариантости, использовать одну вариантность для всех аргументов, во избежании путаницы.
