В C# часто приходится работать с бибилиотеками типов. Но обращаясь к его типам необходимо либо указывать его 
полное имя с его пространством имен (н: System.IO.FileStream), либо использовать директиву using (н: System.IO).

CLR ничего не знает о пространствах имен. При обращении к какому-либо типу среде CLR надо предоставить полное имя типа 
(а это может быть действительно длинная строка с точками) и сборку, содержащую описание типа, чтобы во время 
выполнения загрузить эту сборку, найти в ней нужный тип и оперировать им.

Во время работы на C# директории using позволяют обращаться к типам по сокращенному синтаксису. Компилятор C# просматривает все сборки
сверху-вниз для обнаружения всех типов. Так же каждый файл .cs в VisualStudio автоматом использует кучу разных директив и псевдонимов
по умолчанию (поэтому нам не приходится обращаться к System.Console как Console или к System.Int32 как к int).

В случае одинаковых имен сущностей, необходимо использовать его полное имя, ибо сопутствующая неопределенность чревата ошибками:

using Microsoft; // Определяем приставку "Microsoft."
using Wintellect; // Определяем приставку "Wintellect."
public sealed class Program {
	public static void Main() {
		Wintellect.Widget w = new Wintellect.Widget();
	}
}

Либо использовать директиву using для создания псевдонима:

using Microsoft; // Определяем приставку "Microsoft."
using Wintellect; // Определяем приставку "Wintellect."
using WintellectWidget = Wintellect.Widget;
public sealed class Program {
	public static void Main() {
		WintellectWidget w = new WintellectWidget();
	}
}

Но порой и этого недостаточно. Например: компании Australian Boomerang Company (ABC) и Alaskan Boat Corporation (ABC) 
создали каждая свой тип с именем BuyProduct и собираются поместить его в соответствующие сборки. Не исключено, 
что обе компании создадут пространства имен ABC, в которые и включат тип BuyProduct. Для решения используют 
внешние псевдонимы (extern aliases). Внешние псевдонимы дают также возможность обращаться к одному типу двух (или более) 
версий одной сборки.

Примечание: пространства имен и сборки могут не совпадать: разные типы в одном пространстве имен могут быть распределены в 
разных сборках и наоборот - в одном пространстве имен могут содержаться сущности разных сборок. Таким образом физическое и 
логическое разделение никак между собой не связаны, а пространства имен используются чисто для удобства работы.