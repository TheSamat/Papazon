В C# часто приходится работать с бибилиотеками типов. Но обращаясь к его типам необходимо либо указывать его 
полное имя с его пространством имен (н: System.IO.FileStream), либо использовать директиву using (н: System.IO).

CLR ничего не знает о пространствах имен. При обращении к какому-либо типу среде CLR надо предоставить полное имя типа 
(а это может быть действительно длинная строка с точками) и сборку, содержащую описание типа, чтобы во время 
выполнения загрузить эту сборку, найти в ней нужный тип и оперировать им.

В случае одинаковых имен, необходимо использовать его полное имя, ибо неопределенность чревата ошибками:

using Microsoft; // Определяем приставку "Microsoft."
using Wintellect; // Определяем приставку "Wintellect."
public sealed class Program {
	public static void Main() {
		Wintellect.Widget w = new Wintellect.Widget();
	}
}

Либо использовать директиву using для создания псевдонима:

using Microsoft; // Определяем приставку "Microsoft."
using Wintellect; // Определяем приставку "Wintellect."
using WintellectWidget = Wintellect.Widget;
public sealed class Program {
	public static void Main() {
		WintellectWidget w = new WintellectWidget();
	}
}


Но порой и этого недостаточно. Например: компании Australian Boomerang Company (ABC) и Alaskan Boat Corporation (ABC) 
создали каждая свой тип с именем BuyProduct и собираются поместить его в соответствующие сборки. Не исключено, 
что обе компании создадут пространства имен ABC, в которые и включат тип BuyProduct. Для решения используют 
внешние псевдонимы (extern aliases). Внешние псевдонимы дают также возможность обращаться к одному типу двух (или более) 
версий одной сборки.