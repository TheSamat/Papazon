Так как каждый тип прямо или косвенно наследуется от object, он имеет встроенный открытый (public) экземплярный функционал:

	1) Equals - сравнивает два обьекта на равенство (НЕ ТОЖДЕСТВО!) значения. 
	2) GetHashCode - возвращает хеш-код содержимого обьекта. Для хеш-таблиц лучше переопределить его. 
	3) ToString - по умолчанию возвращает полное имя типа. Рекомендуется переопределить для вывода состояния/значения обьекта
	4) GetType - невиртуальный метод (непереопределяемый), возвращает экземпляр обьекта, производного от Type, идентифицирующий 
вызывающий обьект. Результат часто используют классы, реализующие отражения для получения информации о типе в виде методанных.

а также защищенные (protected) методы:

	1) MemberwiseClone - невиртуальный метод создания нового экземпляра типа с теми же значениями (т.е. не глубокое клонирование, 
когда значимые типы копируются в новый, а ссылочные остаются те же самые), возврающий ссылку на новый экземпляр. 
	2) Finalize - виртуальный метод, вызываемый сборщиком мусора перед удалением обьекта. Статичного аналога не существует. Так же
есть аналог Object.Dispose()???

Статичные классы напрямую наследуются от object и не способны наследоваться от кого-либо еще или иметь наследников, ибо наследование
идет от экземпляра, а у статичного класса их нет, ибо все его состояние в обьекте-типе.

CLR требует, чтобы все обьекты типов создавались оператором new, при этом:

	1) Вычисляется кол-во байтов, нужное для хранения всех экземплярных полей типа и всех его базовых типов (включая object, что 
	   не имеет экземплярных полей) + необходимые всем обьектам кучи поля: указатель на обьект-тип (type object pointer) и 
	   индекс блока синхронизации (sync block index), необходимых среде для управления обьектом.
	2) Выделение необходимой памяти для обьекта в управляемой куче. Выделеннные байты инициализуются нулями.
	3) Инициализация указателя на обьект-тип и индекса блока синхронизации
	4) Вызов конструктора экземпляра типа по сигнатуре, а после вызов конструкторов уже базовых классов
	5) возвращает указатель(ссылку) на созданный обьект.

У new нет противоположного оператора, который бы напрямую удалял выделенную память, это делает среда сборщиками мусора

