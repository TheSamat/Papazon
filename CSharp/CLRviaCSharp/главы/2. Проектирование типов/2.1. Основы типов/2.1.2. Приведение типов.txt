Безопасность типов в CLR - одна из важнейших особенностей. В любой момент времени известеп тип того или иного обьекта. 

Приведение типа одного обьекта к другому - одно из часто используемых инструментов программиста. C# позволяет приводить тип обьекта 
к его базовому совершенно безопасно. 

// Приведение типа не требуется, т. к. new возвращает объект Employee,
// а Object — это базовый тип для Employee. 
Object o = new Employee();

// Приведение типа обязательно, т. к. Employee — производный от Object
// В других языках (таких как Visual Basic) компилятор не потребует
// явного приведения
Employee e = (Employee) o; 

Но надо помнить, что приведение к базовому может сопровождаться потерей данных, что подрывает безопасность данных при приведении типов.
Также бывает ошибка приведения остается незамеченной при компиляции, но выявляется при непосредсвенном выполнении приведения.

Только для приведения одного типа к несвязанному по иеархии наследования нужно создавать отдельные методы/переопределять ToString.

Примечание: На самом деле приведение типов - присваение той же ссылки, с тем отличием, что переменная просто не будет иметь
доступа ко всем членам. на выше написанном примере: При приведении тип будет "object { .Employee}", поэтому его формальный тип - object,
а действительный - Employee. Из-за этого присваивать обьект "o" переменной "e" неявно не выйдет, ибо компилятор основывается на 
формальном типе. В то же время если бы присваивание шло к типу Object (Object e = o), то приведения вообще не было бы. Так же из-за 
этого переменной "о" недоступны члены обьекта .Employee, несмотря на то, что переменная ссылается прямо на обьект. Это из-за 
инкапсуляции, обеспечивающее сокрытие недоступных членов типа.


