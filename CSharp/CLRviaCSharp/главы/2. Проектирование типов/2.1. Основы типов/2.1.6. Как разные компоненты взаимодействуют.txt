В этом разделе рассказано, как во время выполнения взаимодействуют типы, объекты, стек потока и управляемая куча. 
Кроме того, объяснено, в чем различие между вызовом статических, экземплярных и виртуальных методов.

Представим, что запущен проект, инициализирована куча и создан поток с его 1Мб в стеке. Поток остановился на методе Н, 
программа будет делать следующее:

class Employee
{
	public Int32 GetYearsEmployed() {...}
	public virtual String GetProgressReport() {...}
	public static Employee Lookup(String name) {...}
}
sealed class Manager : Employee
{
	public override String GetProgressReport() {...}
}
void H()
{
	Employee e;
	Int32 year;
	e = new Manager();
	e = Employee.Lookup("Joe");
	year = e.GetYearsEmployed();
	e.GetProgressReport();
}


При запуске контекста кода:
	1) Jit-Компилятор выделяет все типы, на которые ссылается код: Employee, Int32, Manager и String (это "Joe"). 
	   Добавляет их в методанные, если они не использовались ранее.
	2) Среда все еще обеспечивает загрузку в домен(приложения всех сборок) и из методанных получает информацию о типах.
	3) Среда в куче создает обьекты-типы данных, представляющие эти типы, т.е. имеют весь его функционал, статистические поля 
	   для всех неиспользованных типов (напоминаем, что в куче все имеют 2 доп параметра в виде указателя на обьект-тип и
	   индекса блока синхронизации). Для всех статистических полей, используемых во всех экземплярах класса, память для них 
	   выделяется в составе соответствующих обьектов-типов.
	4) Среда компилирует код в машинный и принимается его выполнять
	5) Среда в стеке потока выделяет память для локальных переменных (e, employee), автоматически иннициализируя все 
	   локальные переменные значениями null/0 (хоть в попытке прямого обращения к ним, компилятор выдаст ошибку инициализации)
	6) Среда выполняет иннициализацию переменной типом Manager: выделяет память и создает экземпляр типа Manager в куче 
	   со всем необходимым: указатель на обьект-тип (просто обьект, что ссылает на обьект-тип Manager), экземплярные поля 
	   (этой и базовых типов), и инициализирует их null/0, после уже вызывает машинный код конструктора. После исполнения кода в 
	   конструкторе оператор new возвращает указатель на обьект.
	7) Средой вызывается статистический метод Employee.Lookup(...), определяется соответствующий методу обьект-тип, из него 
	   находится точка входа в соответствующий метод. Если необходимо, обрабатывает код массива Jit-компилятором. Исполняется 
	   машинный код метода (предположим, что метод просто берет из бд данные о работнике-менеджере по имени Joe). А это НЕ изменяет 
	   поля в существующем обьекте Manager, на который ссылается переменная е, а создает новый экземпляр типа Manager со 
	   своими значениями полей, а переменной е вернут указатель на новый обьект (с именем Joe). (В последсвии сборщик мусора 
	   удалит старый экщемпляр)
	8) Средой вызывается невиртуальный метод Employee.GetYearsEmployed(), что выполняется так же и инициализирует/присваивает 
	   переменной year значение 5.
	9) Средой вызывается виртуальный метод Employee.GetProgressReport(). Виртуальные методы исполняются иначе: среда 
	   обращается к переменной, от нее к его обьекту (от e к Manager.Joe), от обьекта к обьекту-типу (Manager), из него 
	   рассматривается не переопределен ли метод, в случае переопределения он и вызывается, иначе - метод предка.

Заметка: если метод Lookup в Employee обнаружил бы, что Joe — это всего лишь Employee, а не Manager, то Lookup создаст объект 
Employee, в котором указатель на объект-тип ссылается на объект-тип Employee; это приведет к тому, что выполнится реализация 
GenProgressReport из Employee, а не из Manager, ибо указатель на обьект переменной указывает на другой обьект.

Так же стоит упомянуть, что в начале выполнения кода, среда создает обьект-тип System.Type, на который ссылаются 
указатели обьект-типов Employee, Manager. Сам же System.Type ссылается на System.Type, исключая всю неявность определения типов,
ведь System.Object.GetType просто возвращает ссылку инициализированной переменной на первый встреченный указатель на обьект-тип.

При запуске приложения:
	1) Создается процесс Windows для загрузки CLR
	2) Внутри приложения создается поток (или несколько)
	3) Выделяется стек для каждого потока размером в 1мб, внутри которого хранятся локальные переменные и ссылки в куче(ObjRef на 
	   ReferenceType). 

Заполняется стек с конца. С конца она заполняется по традиции с тех времен, когда еще не было .NET, память была ограничена и 
память для стека и кучи выделялась одна: для кучи с начала, для стека - с конца. После же память для стека стала выделяться отдельно,
а память для кучи стала маштабируемой. Из-за того, что стек заполняется с конца, то при ее заполнении он не может
выделить для себя еще памяти в начало. Для работы со стеком у процессора есть 2 регистра: SS (адрес сегмента) и ESP 
(положение посленего впушенного элемента). При переполнении - занять память рядом - нельзя, она обычно уже занята чем-то.
Выделить второй кусок памяти под стек еще где-то (как делает CLR для кучи) - нельзя - у процессора всего два регистра для стека, 
он не умеет куски, а целостную структуру.

При работе перед вызовом метода стек записывает адресс вызова метода в регистр, а когда выполнется код метода, программа вернется
на этот адресс и будет записывать новые данные поверх записанных ранее данных, а описывать это будет через второй регистр.