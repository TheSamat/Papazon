Иногда удабно/надо определить метод, способный принимать переменчивое число аргументов. Например, в System.String есть методы, 
обьединяющие произвольное число строк.

    static Int32 add(params Int32[] values)
    {
      // Примечание: этот массив можно передавать другими
      // способами, но это просто пример

      Int32 sum = 0;
      if (values != null)
      {
        for (Int32 x = 0; x < values.Length; x++)
          sum += values[x];
      }
      return sum;
    }

Здесь ключевое слово params и изменяет сигнатуру метода, позволяя принимать не только массив Int32, а произвольное перчисление Int32 
экземпляров:

    public static void Main() {
      // Выводит "15"
      Console.WriteLine(Add(new Int32[] { 1, 2, 3, 4, 5 } ));

      // Выводит "15"
      Console.WriteLine(Add(1, 2, 3, 4, 5));
    }

Происходит подобное из-за настраемого params'ом как экземпляр атрибута ParamArray System.ParamArrayAttribute. Так если компилятор C# 
заметит перечисление, а не массив, то генерирует код, собирающий все аргументы в массив и после вызывает метод.

Только последний атрибут может быть помечен params. Этот атрибут должен ссылаться на одномерный массив произвольного типа, null или 
пустой одномерный массив или вообще не указывать параметров:

    public static void Main() {
      // Все строчки выводят "0"

      Console.WriteLine(Add(new Int32[] { })); 
      Console.WriteLine(Add()); 
      // оба передают новый элемент Int32[0] методу Add
      
      Console.WriteLine(Add(null)); 
      // передает методу Add значение null, что более эффективно (не выделяется память под массив)
    }

Для передачи произвольного типа для каждого члена перечисления можно передавать Object типы, но из-за приведения типа и 
упаковки значимых типов это делать не рекомендуется. 

Под капотом компилятор видя метод ищет в методанных все сигнатуры его перегрузок в поисках необходимого, начинае те, что без атрибута
ParamArray, после уже с ним, а если и его не найдется, то уже проверяются методы расширения. Если выбран метод с ParamArray
атрибутом, то выделяется в куче массив, копирующий в себя все переданные параметры.

Так же любой метод, принимающий переменное число параметров снижает производительность из-за необходимости собирать все элементы в 
массив перед его запуском, если конечно не передан явно null. Но по примеру метода System.String.Concat() можно определить 
перегруженные методы по всем часто встречающимся сигнатурам в дополнение к методу с сигнатурой params:

public sealed class String : Object, ... {
 public static string Concat(object arg0);
 public static string Concat(object arg0, object arg1);
 public static string Concat(object arg0, object arg1, object arg2);
 public static string Concat(params object[] args);
 public static string Concat(string str0, string str1);
 public static string Concat(string str0, string str1, string str2);
 public static string Concat(string str0, string str1, string str2, string str3);
 public static string Concat(params string[] values);
}