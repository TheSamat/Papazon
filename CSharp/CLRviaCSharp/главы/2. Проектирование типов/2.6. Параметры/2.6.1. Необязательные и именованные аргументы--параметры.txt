Параметры = аргументы

При выборе параметров метода почти всем можно присваивать значения по умолчанию из-за чего можно не указывать эти параметры, 
принимая уже имеющиеся значения параметров. Но существует возможность при вызове метода указать аргументы, воспользовавшись 
именами параметра метода:

public static class Program 
{
  private static Int32 s_n = 0;
  private static void M(
    Int32 x = 9,
    String s = "A",
    DateTime dt = default(DateTime), 
    Guidguid = new Guid())
  {
    Console.WriteLine(
      "x={0}, s={1}, dt={2}, guid={3}", x, s, dt, guid);
  }

  public static void Main() 
  {
    M();
    // 1. Аналогично: 
    // M(9, "A", default(DateTime), new Guid());

    M(8, "X");
    // 2. Аналогично: 
    // M(8, "X", default(DateTime), new Guid());

    M (5, guid: Guid.NewGuid(), dt: DateTime.Now);
    // 3. Аналогично: 
    // M(5, "A", DateTime.Now, Guid.NewGuid());

    M(s_n++, s_n++.ToString());
    // 4. Аналогично:
    // M(0, "1", default(DateTime), new Guid());
  
    M(s: (s_n++).ToString(), x: s_n++);
    // 5. Аналогично:
    // M(3, "2", default(DateTime), new Guid()); 
  }
}

Переданные параметры в метод читаются компилятором слева-направо без разницы именованно или нет. В четвертом случае мы в начале 
передаем в Int32 x значение s_n (0), после же s_n инкрементируется и передается в String s s_n (1), а после снова инкриментируется. 
В пятом происходит анологичная ситуация, порядок идет слева направо, но именованные параметры записывают свои параметры.

param аргументы не могут иметь значения по умолчанию.

Для работы с параметрами по умалчанию, компилятор использует 2 атрибута: Optional и DefaultParameterValue для аргумента. Оба
заполняют значения в методанных. Так видя в методе отсутствие параметра с атрибутом Optional кломпилятор подставляет его значение из 
методанных DefaultParameterValue.