Обьявляя типы параметров, надо стремиться указывать более базовые типы, предпочитая интерфейсы базовым классам:
IEnumerable<T> заместо сильного типа List<T> или еще более сильного интерфейса ICollection<T> или IList<T>:

	// Рекомендуется здесь использовать параметр слабого типа
	public void ManipulateItems<T>(IEnumerable<T> collection) 
	{ ... }
	// Не рекомендуется здесь использовать параметр сильного типа
	public void ManipulateItems<T>(List<T> collection) { ... }

Причина этому - универсальность. Первый метод может работать с любым типом, реализующий IEnumerable<T>: List<T>, String, Array, в то время
как второй только List<T>. Так при смене типов в аргументах придется либо второй метод подгонять, либо создавать перегруженный метод, 
выполняющий тот же функционал.

Если же параметр предпологает в аргументах именно списки, а не, скажем, строки или дереья, то в качестве типа будет IList<T>.

То же самое касается не только иеархии интерфейсов, а так же к классам с иеархией базовых классов:

	// Рекомендуется здесь использовать параметр мягкого типа
	public void ProcessBytes(Stream someStream) { ... }
	// Не рекомендуется здесь использовать параметр сильного типа
	public void ProcessBytes(FileStream fileStream) { ... }


В то же время, обьявляя тип возвращаемого методом обьекта, желательно выбирать самый "сильный" тип:

	// Рекомендуется в этом методе использовать
	// сильный тип возвращаемого объекта
	public FileStream OpenFile() { ... }
	// Не рекомендуется в этом методе использовать
	// слабый тип возвращаемого объекта
	public Stream OpenFile() { ... }

Здесь предпочтительней первый метод, так как он позволяет вызывающему коду обратиться с возвращаемым обьектом как с FileStream, в то время 
как второй только как Stream, что зачастую может потребовать приведения.


Но порой требуется сохранять возможность изменять возвращаемое значение. Для метода OpenFile() возвращаемый тип (FileStream и его потомки)
вряд ли придется изменить. Но в случае, когда надо вернуть либо List<String>, либо String[] и это еще решается, можно указывать слабый тип:

	// Гибкий вариант: в этом методе используется
	// мягкий тип возвращаемого объекта
	public IList<String> GetStringCollection() { ... }
	// Негибкий вариант: в этом методе используется
	// сильный тип возвращаемого объекта
	public List<String> GetStringCollection() { ... }

Так даже если в будещем придется возвращать вместо List<String> - String[], то метод продолжить работать без редактирования или 
перекомпиляции. Также, необходимо обратить внимание, что выбран самый "сильный" тип из самых "слабых", которые удовлетворяют требованиям. 
В случае, если между ними большая разница, стоит задуматься о перегрузке.


В С++ и некоторых других языках параметры методов могут быть константами, т.е. неизменяемыми. Параметры методов в C#, передаваемые по 
значению - просто копии, а передаваемые по ссылке - априори изменяемые, посему передаваемые параметры по значению не меняются, поскольку
будут использованы копии, а по ссылке - не могут быть использованы. 