В C# есть возможность определения типа локальных переменных, часто педаваемых как аргументы метода, по их инициализирующим выражениям:

    private static void ShowVariableType<T>(T t) 
    {
      Console.WriteLine(typeof(T));
    }

    private static void ImplictlyTypedLocalVariables()
    {
      var name = "Jeff";
      ShowVariableType(name); //out: System.String

      //var n = null; //error
      var x = (String) null; //допустимо, но зачем?
      ShowVariableType(x); //out: System.String

      var numbers = new Int32[] {1,2,3,4,5};
      ShowVariableType(numbers); //out: System.Int32[]

      var collection = new Dictinary<String, Single>() 
      { 
        {"Grant", 4.0f}
      }
      ShowVariableType(collection);
      //out: System.Collections.Generic.Dictinare`2
                    //System.String, System.Single]

      foreach (var item in collection)
      {
        ShowVariableType(item);
        //out: System.Collections.Generic.KeyValuePair`2
                         //[System.String,System.Single]
      }
    }

1) В первом случае все ок
2) Во вротом (комментарий) же вылетает ошибка - нельзя присваивать тип null для переменных с неявно заданным типом.
3) В третьем же случае null привели к String. Дело в том, что null можно приводить к вообще любому ссылочному типу.
4) Здесь же var пригодился для сокращения кода и облегчения ведения кода, когда типы коллекции поменяют.
5) Демонстрация пользы var внутри инструкций foreach, using и for. 

Также var необходим при работе с анонимными типами. Тип аргумента метода, поля типа var'ом определять нельзя.

ВНИМАНИЕ: не путать var и dynamic. var не более чем синтаксическое сокращение, заставляющий C# компилятор при компиляции определять 
тип переменной. dynamic же можно использовать как тип аргументов, полей типов. К var нельзя приводить типы, а к dynamic же можно. 
Переменные, обьявленные var должны быть заданы явно, что для dynamic не обязательно.