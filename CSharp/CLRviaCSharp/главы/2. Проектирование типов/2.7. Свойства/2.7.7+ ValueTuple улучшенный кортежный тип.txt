После обновлений создали ValueTuple, удобный в использовании и устранивший большинство проблем Tuple:
	var valueTuple = new ValueTuple<int, int>(1, 2);

ValueTuple не является потомком Tuple, более того, он является структурой, наследующей ValueTupe и имеет иную логику работы.

Сам он имеет как прямое обращение, так и облегченную синтаксическую конструкцию (Обратите внимание, что при обоих реализациях тип ValueTuple 
высвечивается перечислением типов в скобках!):
	var valueTuple = (1, 2);

Заметка: Поскольку ValueTuple добавили с C# v4.7, то версиям ранее придется устанавливать его через пакет NuGet

Такое нововведение позволяет облегчить возвращение данных из метода или их передачу в качестве аргумента облегченной синтаксической 
конструкцией, уменьшить количество печаток при написании кода и даже позволяет yказывать тип без оператора var:
	(int, byte) valueTuple = (1, 2);

Стоит помнить, что облегченный синтаксис для обьявления кортежа с одним свойством анологичен по синтаксису с приведением типов и посему 
не доступен (а так же попросту не нужен, ибо легче передавать его напрямую) и для его использования необходимо прямое обращение:
	var singleValueTuple = (1);					// прямое присвоение int типа 
	(int) singleValueTuple = (1);				// ошибка синтаксиса: идет приведение типа, а не обьявление переменной
	var valueTuple = new ValueTuple<int>(1);	// прямое обращение к инициализации ValueTuple

Так же перекочевали статистические методы инициализации типов (Обратите внимание, что ValueTuple высвечивается при наличии только одного
свойства):
	var singleValueTuple = ValueTuple.Create(1);

Так же ValueTuple вмещает в себя бесконечное количество совйств, который внутри под капотом автоматом создает длинные цепочки вложенных 
внутри себя ValueTuple (кстати, у него есть перегрузка с int параметрами для ускорения работы):
	var ValueTuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

А еще ValueTuple может возможность обращаться к своим свойствам по имени, а не по ItemX, определяемым автоматически. 
	(int Id, int Age, string Name) valueTuple = (0, 12, "Name");
    var singleValueTuple = ValueTuple.Create(1);
    valueTuple.Age;         // хоть обращения и правильны, вызываеются свойства, а не методы, посему и возникает синтаксическая ошибка
    singleValueTuple.Item1; // +

Причем имена свойств могут быть определены и в значении экземпляра, хоть приоритет будет на именах обьявленного типа:
	(int Id, int Age, string Name) valueTuple = (StudentId: 0, StudentAge: 12, Login: "Name");
    valueTuple.Login;	// ошибка синтаксиса: совйства с именем Login игнорируется в пользу Name
    valueTuple.Name;	// правильное обращение

А так же если в значение передаются переменные, то в типе автоматически в свойствах указываются их имена:
    int Id = 0;
    string Name = "name";
    int Age = 12;
    
	var valueTuple = (Id, Age, Name);
    valueTuple.Id;

При работе с кортежами необходимо пользоваться всеми преимуществами ValueTuple и при этом обдумывать не только ее реализацию, а еще и
ее необходимость. Ниже представлен метод с плохим и хорошим оформлением кортежей (но не кода! его реализацию можно упростить, он просто
является примером использования кортежей одновременно для возвращаемого значения и его аргументов):

    public static (int, int) MinMaxPrototype((int, int) pair)
    {
        return (Math.Min(pair.Item1, pair.Item2), Math.Max(pair.Item1, pair.Item2));
    }
    public static (int Min, int Max) MinMax((int First, int Second) pair)
    {
        return (Math.Min(pair.First, pair.Second), Math.Max(pair.First, pair.Second));
    }

Учитываейте, что ValueTuple - структура, из-за чего из передаваемого кортежа скопируются в новый значения свойств, но не их имена. 
Благодаря этому можно определять новые имена свойств. Так же при передаче ValueTuple в object, происходит упаковка.

Также ValueTuple может использоваться с Деконструкторами:
    public class Program
    {
        private static void Main(string[] args)
        {
            Person Sam = new Person { Name = "Sam", Age = 23 };
            (string name, int age) = Sam;
            Console.WriteLine(name + ": " + age.ToString());
        }
    }

    public class Person
    {
        public string Name { get; set; }
        public int Age { get; set; }
        public void Deconstruct(out string name, out int age)
        {
            name = this.Name;
            age = this.Age;
        }
    }

Деконструктор (не путать с деконструктром!) - метод, позволяющмй разбить составной обьект на части (выполняет декомпозицию) и является
синтаксическим сахаром. С VulueTuple позволяет присваивать значение переменным в порядке возвращаемых типов.

Деструктор (не путать с Деконструкторами) - метод деинициализации любых обьектов. В C# вызывается только CLR в рамках сборки мусора

Так же можно опускать не нужные значения:
    Person Sam = new Person { Name = "Sam", Age = 23 };
    (string name, _) = Sam;
    Console.WriteLine(name);

Но самое большая разница между ValueTuple и Tuple - возможность изменения состояния. У Tuple доступно только автосвойство {get;}, а у
ValueTuple - поле! И он может его заменять (напомним, что ValueType лучше не изменять, ибо в теории они для этого не предназначены,
будут созданы новые обьеты с новым значением на месте старых):
    ValueTuple<int> a = new ValueTuple<int>(0);
    a.Item1 = 1;