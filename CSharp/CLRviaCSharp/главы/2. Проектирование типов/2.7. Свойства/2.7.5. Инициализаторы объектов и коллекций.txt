Создание обьекта с заданием некоторых открытых свойств (или полей для этого случая) распространено:
	Employee e = new Employee() { Name = "Jeff", Age = 45 };

Для C# компилятора это равносильно:
	Employee e = new Employee();
	e.Name = "Jeff";
	e.Age = 45;

Функция подобного сокращенного синтаксиса облегчает читаемость кода:
	String s = new Employee() { Name = "Jeff", Age = 45}.ToString().ToUpper();

Также C# позволяеят опустить круглые скобки перед открытием фигурной скобкой, если вызывается конструктор без параметров:
	String s = new Employee { Name = "Jeff", Age = 45}.ToString().ToUpper();

А поскольку иницилизатор выполняется после конструктора, то он может перезаписывать поля или дополнять конструктор:
	Employee Jeff = new Employee(name: Jeff) { Name = "Jeff Borderlens", Age = 45}.ToString().ToUpper();

Если тип свойства (т.е. тип поля) реализует интерфейс IEnumerable или IEnumerable<T>, то свойство является коллекцией, а 
инициализация коллекции - дополнительной операцией, а не замещающей:

	public sealed class Classroom 
	{
		private List<String> m_students = new List<String>();
		public List<String> Students { get { return m_students; }}
		public Classroom() { }
	}

	public static void Main() 
	{
		Classroom classroom = new Classroom 
		{
			Students = { "Jeff", "Kristin", "Aidan", "Grant" }
		};
		foreach (var student in classroom.Students)
			Console.WriteLine(student);
	}

Здесь компилятор видит, что тип свойсва Student - List<String> реализует IEnumerable<String> и предпологая, что тип предоставляет 
метод Add() генерирует код:

	public static void M() {
		Classroom classroom = new Classroom();
		classroom.Students.Add("Jeff");
		classroom.Students.Add("Kristin");
		classroom.Students.Add("Aidan");
		classroom.Students.Add("Grant");

		// Вывести имена 4 студентов, находящихся в классе
		foreach (var student in classroom.Students)
			Console.WriteLine(student);
	}

В случае, если бы тип реализовывал бы IEnumerable или IEnumerable<T>, но не предоставлял бы метод Add(), то при таком синтаксисе 
компилятор бы вызвыл ошибку. 

Эти правила распростаняется и на те типы, что имеют более одного параметра в методе Add():

	var table = new Dictionary<String, Int32> 
	{
		{ "Jeffrey", 1 }, { "Kristin", 2 }, { "Aidan", 3 }, { "Grant", 4 }
	};

равносильно:

	var table = new Dictionary<String, Int32>();
	table.Add("Jeffrey", 1);
	table.Add("Kristin", 2);
	table.Add("Aidan", 3);
	table.Add("Grant", 4);


