Так get свойства рассмотренных ранее не принимают параметры, поэтому они свойства без параметров (parameterless properties).
Они проще устроены, а обращения к ним идентична обращению к полю. Но так же существуют свойства с параметрами, которые получают 
один и более аргумента/-ов. В разных языках они называются по разному, в C# - индексаторы, в Visual Basic - свойства по умолчанию.

В C# синтаксис индексаторов (свойств с параметрами) напоминает синтаксис массивов. Иначе говоря, перегружение оператора []:

    public sealed class BitArray
    {
        // Закрытый байтовый массив, хранящий биты
        private Byte[] m_byteArray;
        private Int32 m_numBits;

        // Конструктор, выделяющий память для байтового массива
        // и устанавливающий все биты в 0
        public BitArray(Int32 numBits)
        {
            // Начинаем с проверки аргументов
            if (numBits <= 0)
                throw new ArgumentOutOfRangeException("numBits must be > 0");
            // Сохранить число битов
            m_numBits = numBits;
            // Выделить байты для массива битов
            m_byteArray = new Byte[(numBits + 7) / 8];
        }

        ///
        /// Индексатор (свойство с параметрами)
        ///
        public Boolean this[Int32 bitPos]
        {

            // Метод доступа get индексатора
            get
            {
                // Сначала нужно проверить аргументы
                if ((bitPos < 0) || (bitPos >= m_numBits))
                    throw new ArgumentOutOfRangeException("bitPos");
                // Вернуть состояние индексируемого бита
                return (m_byteArray[bitPos / 8] & (1 << (bitPos % 8))) != 0;
            }

            // Метод доступа set индексатора
            set
            {
                if ((bitPos < 0) || (bitPos >= m_numBits))
                    throw new ArgumentOutOfRangeException(
                  "bitPos", bitPos.ToString());
                if (value)
                {
                    // Установить индексируемый бит
                    m_byteArray[bitPos / 8] = (Byte)
                    (m_byteArray[bitPos / 8] | (1 << (bitPos % 8)));
                }
                else
                {
                    // Сбросить индексируемый бит
                    m_byteArray[bitPos / 8] = (Byte)
                    (m_byteArray[bitPos / 8] & ~(1 << (bitPos % 8)));
                }
            }
        }
    }

...

    // Выделить массив BitArray, который может хранить 14 бит
    BitArray ba = new BitArray(14);
    // Установить все четные биты вызовом метода доступа set
    for (Int32 x = 0; x < 14; x++)
    {
        ba[x] = (x % 2 == 0);
    }
    // Вывести состояние всех битов вызовом метода доступа get
    for (Int32 x = 0; x < 14; x++) 
    {
        Console.WriteLine("Bit " + x + " is " + (ba[x] ? "On" : "Off"));
    }


В типе BitArray индексатор принимает один параметр bitPos типа Int32, выполняющий функции индекса.

Индексаторы часто используются для коллекций. Тип System.Collections.Generic.Dictionary предлагает индексатор ключ, возвращающий значение.
В отличии от свойств, тип может иметь множество перегруженных индексаторов, если их сигнатуры различны.

У set свойства же есть скрытый парамтр (в C# это value), указывающий новое значение "индексируемого элемента".

Для CLR же что без, что с параметрами свойства одинаково представлены методами. Индексаторы могут определяться только для экземпляров. 
Хоть CLR может поддерживать статичные свойства-индексаторы, C# подобного не допускает напрямую. Так же из-за этого в методанные 
определения свойств с параметрами отправляются так же как и без них:
    1) метод get свойства с параметрами генерируется только в том случае, если у свойства определен метод доступа get;
    2) метод set свойства с параметрами генерируется только в том случае, если у свойства определен метод доступа set;
    3) определение свойства в метаданных управляемого модуля генерируется всегда; в метаданных нет отдельной таблицы для хранения 
       определений свойств с параметрами: ведь для CLR свойства с параметрами не отличаются от обычных свойств, ибо оба они просто методы.
       и выгледят так же:

    public sealed class BitArray 
    {
        // Метод доступа get индексатора
        public Boolean get_Item(Int32 bitPos) { /* ... */ }
        // Метод доступа set индексатора
        public void set_Item(Int32 bitPos, Boolean value) { /* ... */ }
    } 

Если в документации написано, что тип поддерживает свойство Item, значит, этот тип поддерживает индексатор. Кроме имени поля Item, 
для него необходимо применить атрибут System.Runtime.CompilerServices.IndexerNameAttribute у свойств, чтобы заместо get_Item и set_Item 
методы назывались get_Bit и set_Bit:

    public sealed class BitArray 
    {
        [IndexerName("Bit")]
        public Boolean this[Int32 bitPos] 
        {
            // Здесь определен по крайней мере один метод доступа
        }
    }

Так C# запрещает обращаться к индексатором по имени (оно по умолчанию у всех Item, у System.String оно Chars), посему нельзя иметь 
индексаторы одинаковой сигнатуры или одинаковыми именами:

    public sealed class SomeType 
    {
        // Определяем метод доступа get_Item
        public Int32 this[Boolean b] 
        {
            get { return 0; }
        }
        // Определяем метод доступа get_Jeff
        [IndexerName("Jeff")]
        // error CS0111: Class 'SomeType' already defines a member 
        // called 'this' with the same parameter types
  
        public String this[Boolean b] 
        {
            get { return null; }
        }
    }


Мой пример:


using System;
using System.Collections;
using System.Collections.Generic;

public class Program
{
    private static void Main(string[] args)
    {
        SomeClass some = new SomeClass(2, 2, 2);
        some[0, "0", false] = "Один";
        some[0, "0", true] = "Два";
        some[0, "1", false] = "Три";
        some[0, "1", true] = "Четыре";
        some[1, "0", false] = "Пять";
        some[1, "0", true] = "Шесть";
        some[1, "1", false] = "Семь";
        some[1, "1", true] = "Восемь";

        some.Print();
    }
}

public class SomeClass
{
    private int xLimit;
    private int yLimit;
    private int zLimit;

    private Dictionary<int, int> xIndex;
    private Dictionary<string, int> yIndex;
    private Dictionary<bool, int> zIndex;

    private int xConter;
    private int yConter;
    private int zConter;

    private ClassA[,,] aArray;
    public ClassA this[int x, string y, bool z]
    {
        get
        {
            if (xIndex.ContainsKey(x))
                if (yIndex.ContainsKey(y))
                    if (zIndex.ContainsKey(z))
                        return aArray[xIndex[x], yIndex[y], zIndex[z]];
            return null;
        }
        set
        {
            if (!xIndex.ContainsKey(x))
                xIndex[x] = xConter++;
            if (!yIndex.ContainsKey(y))
                yIndex[y] = yConter++;
            if (!zIndex.ContainsKey(z))
                zIndex[z] = zConter++;

            if (xConter > xLimit || yConter > yLimit || zConter > zLimit)
                throw new ArgumentException();

            aArray[xIndex[x], yIndex[y], zIndex[z]] = value;
        }
    }
    public SomeClass(int x, int y, int z)
    {
        if (x < 1 || y < 1 || z < 1 || z > 2)
        {
            throw new ArgumentException();
        }
        xLimit = x;
        yLimit = y;
        zLimit = z;

        xIndex = new Dictionary<int, int>();
        yIndex = new Dictionary<string, int>();
        zIndex = new Dictionary<bool, int>();

        xConter = 0;
        yConter = 0;
        zConter = 0;

        aArray = new ClassA[x, y, z];
    }
    public void Print()
    {
        for (int x = 0; x < xLimit; x++)
            for (int y = 0; y < xLimit; y++)
                for (int z = 0; z < zLimit; z++)
                    Console.WriteLine(aArray[x,y,z]);
    }
}
public class ClassA
{
    private string Value;
    public ClassA(string value)
    {
        Value = value;
    }
    public override string ToString()
    {
        return this.Value;
    }
    public static implicit operator ClassA(string s)
    {
        return new ClassA(s);
    }
}