Кортежный тип - тип, не содержащий в себе логики за исключением хранения данных.

Существует структура ValueTuple, который удобней и представлен ниже Tuple.

В пространстве имен System определены несколько обобщенных кортежных типов, наследующие Object, отличающихся количеством обобщенных 
параметров. Один из низ класс Tuple:

    // Простая форма:
    [Serializable]
    public class Tuple<T1> {
        private T1 m_Item1;
        public Tuple(T1 item1) { m_Item1 = item1; }
        public T1 Item1 { get { return m_Item1; } }
    }

    // Сложная форма:
    [Serializable]
    public class Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> {
        private T1 m_Item1; private T2 m_Item2;
        private T3 m_Item3; private T4 m_Item4;
        private T5 m_Item5; private T6 m_Item6;
        private T7 m_Item7; private TRestm_Rest;

        public Tuple(T1 item1, T2 item2, T3 item3,
        T4 item4, T5 item5, T6 item6, T7 item7, TRest t)
        {
            m_Item1 = item1; m_Item2 = item2; m_Item3 = item3;
            m_Item4 = item4; m_Item5 = item5; m_Item6 = item6;
            m_Item7 = item7; m_Rest = rest;
        }

        public T1 Item1 { get { return m_Item1; } }
        public T2 Item2 { get { return m_Item2; } }
        public T3 Item3 { get { return m_Item3; } }
        public T4 Item4 { get { return m_Item4; } }
        public T5 Item5 { get { return m_Item5; } }
        public T6 Item6 { get { return m_Item6; } }
        public T7 Item7 { get { return m_Item7; } }
        public TRest Rest { get { return m_Rest; } }
    }


Как и анонимные типы Tuple создается только раз и остается неименным (все свойства доступны только для чтения) как и анонимные типы. 
Также Tuple имеет переопределннные методы CompareTo, Equals, GetHashCode и ToString, и новое свойство Size. К тому же все типы Tuple 
реализуют интерфейсы IStructuralEquatable, IStructuralComparable и IComparable, поэтому вы можете сравнивать два объекта типа Tuple 
друг с другом и смотреть, как их поля сравниваются. Так же Tuple полностью сериализуемый.

Все свойства в Tuple имеют имена от Item1 до Item7 и TRest. Это очень не удобно. Так же при определения Tuple надо определять используемые
им типы, ибо он generic что муторно. Для облегчения синтаксиса создан не generic класс Tuple, который содержит generic методы для
создания generic Tuple:

    [__DynamicallyInvokable]
    public static class Tuple
    {
        [__DynamicallyInvokable]
        public static Tuple<T1> Create<T1>(T1 item1) { ... }
        [__DynamicallyInvokable]
        public static Tuple<T1, T2> Create<T1, T2>(T1 item1, T2 item2) { ... }
        ...
        [__DynamicallyInvokable]
        public static Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> Create<T1, T2, T3, T4, T5, T6, T7, TRest>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest itemTest) { ... 
    }

Пример метода, использующего тип Tuple для возвращения двух частей информации в вызывающий метод:

    // Возвращает минимум в Item1 и максимум в Item2
    private static Tuple<Int32, Int32>MinMax(Int32 a, Int32 b) 
    {
        return new Tuple<Int32, Int32>(Math.Min(a, b), Math.Max(a, b));
    }

    // Пример вызова метода и использования Tuple
    private static void TupleTypes() 
    {
        varminmax = MinMax(6, 2);
        Console.WriteLine("Min={0}, Max={1}",
        minmax.Item1, minmax.Item2); // Min=2, Max=6
    }

Очень важно, чтобы до определении типа Tuple все договорились об используемых им типах, ибо Tuple обьект-типы имеют Generic происхождение,
зависимое от используемых в нем типов и при этом очень легко опечатываемо при написании кода. А поскольку его можно использовать в 
качестве аргумента и возвращаемого типа (хоть и с синтаксическими проблемами), то это серьезный вопрос.

Для созданий типа Tuple с более чем 8 элементами, нодо создайть другой обьект Tuple и передайте его в Rest:

    var t = Tuple
      .Create(0, 1, 2, 3, 4, 5, 6, Tuple.Create(7, 8));

    Console.WriteLine(
      "{0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}",
      t.Item1, t.Item2, t.Item3, t.Item4, t.Item5, t.Item6,
      t.Item7, t.Rest.Item1.Item1, t.Rest.Item1.Item2);


Но Tuple задается не динамически и не может для изменяться по ходу работы, необходимо именно что создавать новый экземпляр для этого.

Примечание: также можно воспользоваться System.Dynamic.ExpandoObject из System.Core.dll assembly. При использовании этого класса с 
динамическим типом C# (о котором говорится в главе 5) появляется другой способ группировки наборов свойств (пар ключ-значение) вместе.
Полученный в результате тип не обладает безопасностью типов на стадии компиляции, зато синтаксис выглядит отлично (хотя вы лишаетесь 
поддержки IntelliSense), а объекты ExpandoObject могут передаваться между C# и такими динамическими языками, как Python. Пример кода с 
использованием объекта ExpandoObject: 
    dynamic e = new System.Dynamic.ExpandoObject();
    e.x = 6; // Добавление свойства 'x' типа Int32
             // со значением 6
    e.y = "Jeff"; // Добавление свойства 'y' строкового типа
                  // со значением "Jeff"
    e.z = null;   // Добавление свойста 'z' объекта
                  // со значением null

    // Просмотр всех свойств и других значений
    foreach (var v in (IDictionary<String, Object>)e)
        Console.WriteLine("Key={0}, V={1}", v.Key, v.Value);
    // Удаление свойства 'x' и его значения
    var d = (IDictionary<String, Object>)e;
    d.Remove("x");

Но не стоит этим злоупотреблять, ибо это замедляет работу, подрывает безопасность типов и непредсказуем. Так же ExpandoObject не выдает
ошибок синтаксиса к обращению к несуществующим полям и часто выдает RunTimeExseption.
