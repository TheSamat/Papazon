Во многих типах определяется состояние типа, которую можно прочесть и/или изменить. В CLR это реализовано в виде полей. Часто бывает так,
что необходимо инкапсулироваль тип - ограничить состояние типа (и/или его потомков): запретить/ограничить доступ к чтению/изменению поля, 
ограничить возможный диапозон значений поля, а также настроить логические поля, не записанные в поле, но с которыми необходимо работать. 

Для всего этого определены необходимо ограничить поле: private, если необходимо ограничить поле и от потомков, или protected, если 
необходимо дать возможность изменять поле потомкам. А для доступа к ним можно определить специальные методы доступа (accessor):

    public sealed class Employee {
        private String m_Name; 
        private Int32 m_Age; // Поле должно быть положительным
        public String GetName() 
        {
            return(m_Name);
        }
        public void SetName(String value) 
        {
            m_Name = value;
        }
        public Int32 GetAge() 
        {
            return(m_Age);
        }
        public void SetAge(Int32 value) 
        {
            if (value < 0)
                throw new ArgumentOutOfRangeException(
                    "value", value.ToString(),
                    "The value must be greater than or equal to 0");
            m_Age = value;
        }
    }

    e.SetName("Jeffrey Richter"); // Обновление имени сотрудника
    String EmployeeName = e.GetName(); // Получение возраста сотрудника
    e.SetAge(41); // Обновление возраста сотрудника
    e.SetAge(-5); // Выдача исключения
                  // ArgumentOutOfRangeException
    Int32 EmployeeAge = e.GetAge(); 
    // Получение возраста сотрудника

Так модификаторами доступа мы ограничиваем доступ к полям для редактирования и чтения отдельно, а отстутствием соответствующих методов 
мы запрещаем соответственно запись и чтение. Дополнительная логика так же легко настраивается.

Но это порождает 2 проблемы: необходимость писать больше кода при реализации класса, а так же необходимость обращаться к полям через 
методы. Первое не должно быть большой проблемой, ибо заставляет писать код обдуманней. Но CLR поддерживает механизм свойств, что
решает вторую проблему и сильно облегчает первую:

    public sealed class Employee {
        private String m_Name;
        private Int32 m_Age;

        public String Name 
        {
            get { return(m_Name); }
            set { m_Name = value; } // Ключевое слово value
        } // идентифицирует новое значение
        public Int32 Age 
        {
            get { return(m_Age); }
            set 
            {
                if (value < 0)  // Ключевое слово value всегда
                                // идентифицирует новое значение
                throw new ArgumentOutOfRangeException(
                    "value", value.ToString(),
                    "The value must be greater than or equal to 0");
                m_Age = value;
            }
        }
    } 

    e.Name = "Jeffrey Richter";   // "Задать" имя сотрудника
    String EmployeeName = e.Name; // "Получить" имя сотрудника
    e.Age = 41;                   // "Задать" возраст сотрудника
    e.Age = -5;                   // Вброс исключения
                                  // ArgumentOutOfRangeException
    Int32 EmployeeAge = e.Age;    // "Получить" возраст сотрудника

Ключевое слово value - передаваемое в свойство значение.

Можно считать свойства "умными" полями, т.е. полями с дополнительной логикой. CLR поддерживает статические, экземплярные, абстрактные и 
виртуальные свойства. Кроме того, свойства могут помечаться модификатором доступа и определяться в интерфейсах, но они не могут обладать
типом void.

Говоря о свойствах, имеют ввиду пару get и set. Однако отсутствие того или иного запрещает соответственно запись и чтение (а их 
отсутстие говорит о недоступности поля).

Свойства часто обращаеются к закрытому полю, называемым резервным. Так же бывает такое, что свойства не обращаются к резервному полю, 
т.е. тип поддерживает поле, которе не доступно обьекту: неизменяемые свойства, вычисляемые при выполнении: длена массива, количество 
символов в строке. Реализуются они как обычные свойства, но не обращаются к какому-нибудь полю и по очевидным причинам подобные свойства
доступны только для чтения.

Для CLR не существует свойств. Они для него определены как методы get_X, set_X, где X - имя свойства (свойства не обязаны иметь 
индентичные с полями имена). C# компилятор под капотом создает методы get и set, если они определены в свойсте, но в метаданных 
управляемого модуля определение свойства генерируются всегда. Так же эти методы можно определить вручную:

    public sealed class Employee 
    {
        private String m_Name;
        private Int32 m_Age;
        public string Name  // ошибка компиляции: свойство уже определено 2мя соответствующими методами
        {
            get { return m_Name; }  // ошибка компиляции: get_Name() уже определен
        }
        public String get_Name()
        {
            return m_Name;
        }
        public void set_Name(String value) 
        {
            m_Name = value; 
            // Аргумент value всегда идентифицирует новое значение
        }
        public Int32 get_Age() 
        {
            return m_Age;
        }
        public void set_Age(Int32 value) 
        {
            if (value < 0) 
            { 
                // value всегда идентифицирует новое значение
                throw new ArgumentOutOfRangeException(
                "value", value.ToString(),
                "The value must be greater than or equal to 0");
            }
            m_Age = value;
        }
    } 

Итого свойство - это мешанина из поля, 1-2 методов свойства и методанных, хранящих определение свойств, но не используемых CLR - он 
будет использовать методы при каждом обращении к полю при определении соответствующего свойства, и по сути является чистым синтаксическим
сахаром C#. 

Стоит помнить, что использование даже самого простого свойства медленней, чем прямое обращение к полю, но в задачах, не требующих 
жесткой оптимизации или когда целостность данных важнее скорости, использование свойст рекомендуется. А аксессеры для доступа к полям
лучше переделать под свойства.