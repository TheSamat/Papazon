Анонимные типы - кортежный тип и нужен в случаях, когда нужно упаковать какие-то данные в одну сущность в виде свойств для чтения, 
для разных действий. Кортежный тип - тип, не содержащий в себе логики за исключением хранения данных.

Механизм анонимных типов позволяет автоматически обьявлять кортежный тип простым синтаксисом. Кортежный тип (tuple type) - тип, 
содержащий коллекцию свойств, каким-то образом связанных друг с другом:

    // Определение типа, создание сущности и 
    // инициализация свойств
    var o1 = new { Name = "Jeff", Year = 1964 };
    // Вывод свойств на консоль
    Console.WriteLine("Name={0}, Year={1}", o1.Name, o1.Year); // Вывод:
    // Name=Jeff, Year=1964 

Здесь создается анонимный тип оператором new, после которого не было имени типа. Так компилятор создает новый тип, но не сообщает
какое оно (из-за чего и обьявлен анонимным). Для работы с ним жизненно необходим var.

Под капотом при определении анонимного типа компилятор определяет тип каждого выражения, создает закрытые поля для этих типов, для 
каждого поля типа создает открытые свойства только для чтения и для всех выражений создает один конструктор. В конструкторе 
инициализируются закрытые поля типа по результирующим значениям переданных выражений. Так же компилятор переопределяет методы Equals(), 
GetHashCode() и ToString(). Код самого типа выглядит так:

    [CompilerGenerated]
    internal sealed class <>f__AnonymousType0<...> : Object 
    {
        private readonly t1 f1;
        public t1 p1 { get { return f1; } }

        ...

        private readonly tn fn;
        public tn pn { get { return fn; } }

        public <>f__AnonymousType0<...>(t1 a1, ..., tn an) 
        {
            f1 = a1; ...; fn = an; // Назначает все поля
        } 
        public override Boolean Equals(Object value) 
        {
            // Возвращает false, если какие-либо поля не совпадают;
            // иначе возвращается true
        }
        public override Int32 GetHashCode() 
        {
            // Возвращает хеш-код, сгенерированный из 
            // хеш-кодов полей
        }
        public override String ToString() 
        {
            // Возвращает пары "name = value", разделенные точками
        }
    }

Методы Equals() и GetHashCode() создаются, чтобы экземпляры анонимного типа могли использоваться в хэш таблицах. Неизменяемые свойства
защищают хэш код обьекта от изменений. Изменения хеш-кода обьекта, используемого в качества ключа в хэш-таблице может помешать найти 
обьект. А ToString() - для упращения отладки. 

Так же можно определять анонимные типы переменными и их свойствами/полямми:

    String Name = "Grant";
    DateTime dt = DateTime.Now;
    // Анонимный тип с двумя свойствами
    // 1. Строковому свойству Name назначено значение Grant
    // 2. Свойству Year типа Int32 Year назначен год из dt
    var o2 = new { Name, dt.Year };

Так имена полей будут представлелны именем переменной Name и менем свойства Year соответственно, а их типы - типом переменной string и
типом свойства int соответственно.

При обьявлении уже определенного анонимного типа, компилятор создаст только новый экземпляр соответствующего типа. Для этого они 
обязательно должны иметь одинаковую структуру: имена и типы полей одинаковы и определелны в одинаковом порядке.

Это дает массу возможностей: проверить анонимные типы на содержание/сравнение поля, сравнить их, сделать массив из них и т.п.:

    // Это работает, так как все объекты имею один анонимный тип
    var people = new[] {
        o1, // См. ранее в этом разделе
        new { Name = "Kristin", Year = 1970 },
        new { Name = "Aidan", Year = 2003 },
        new { Name = "Grant", Year = 2008 }
    };

    // Организация перебора массива анонимных типов
    // (ключевое слово var обязательно).
    foreach (var person in people)
        Console.WriteLine("Person={0}, Year={1}", person.Name, person.Year);

Анонимные типы часто используются в LINQ:

    String myDocuments = Environment.GetFolderPath  (Environment.SpecialFolder.MyDocuments);

    var query =
        from pathname in Directory.GetFiles(myDocuments)
        let LastWriteTime = File.GetLastWriteTime(pathname)
        where LastWriteTime > (DateTime.Now - TimeSpan.FromDays(7))
        orderby LastWriteTime
        select new { Path = pathname, LastWriteTime };

    foreach (var file in query)
        Console.WriteLine("LastWriteTime={0}, Path={1}", file.LastWriteTime, file.Path);

Экземпляры анонимных типов не стоит передавать в качестве параметра или возвращенного обьекта, ибо только компилятору будет доступен его
обьект-тип и для приведения к нему и для его использования. Для подобного лучше подойдет тип System.Tuple (но и это не рекомедуется, 
лучше будет задать нормальный класс и работать с ним), а не мучиться с object возвращаемым или принимаемым типом и последующим 
присваиваниием с оператором var.