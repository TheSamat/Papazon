В C# также есть упрощенный синтаксис для свойств, не имеющих дополнительной логики, позволяющая не обьявлять вспомогательное поле (privatr
поле, скоротым работают свойства) и называемое автоматически реализуемыми свойствами (Automatically Implemented Properties, AIP), 
предлагающий реализацию от компилятора по умолчанию, который в любой момент можно переопределить. Это важно, потому как если обьявить
поле без свойств и обращаться к нему в коде, то последующее определение его свойств потребует перекомпилировки, поскольку код теперь 
обращается к методу, а не к полю:

public sealed class Employee {
    // Это свойство является автоматически реализуемым
    public String Name { get; private set; }
    private Int32 m_Age;
    public Int32 Age {
        get { return(m_Age); }
        set 
        {
            if (value < 0) 
                // value всегда идентифицирует новое значение
                throw new ArgumentOutOfRangeException(
                "value", value.ToString(),
                "The value must be greater than or equal to 0");
            m_Age = value;
        }
    }
}

Лучше определять автосвойства, чем голые поля, ибо обращение к состоянию обьекта будет проходить через дополнительный слой логики, который
можно добавить/изменить позднее, в отличии от поля. Но это имеет проблемы, ибо автосвойства отличабтся от свойств:
    1) Механизм сериализации при выполнении сохраняет имя поля в сериализированном потоке. Но имя автосвойства AIP может измениться 
       во время каждой компиляции, делая десериализацию небезопасным. Если сериализация и десериализация нужны для работы, то 
       рекомендуется прописывать свойства вручную.
    2) Автосвойства не поддерживают точки останова для отладки. Только прописанные свойства могут это и посему и рекомендуются.
    3) Автосвойство, доступное только для чтения или записи без возможности обращения к полю внутри типа делает их определение в типе 
    бессмысленным в большинстве случаев. Лучше использовать поля доступное только для чтения для {get;} и {private get; set;} заместо {set;}

Так же все свойства отличаются от методов-акселераторов рядом минусов:
    1) Обращение свойствам идентично обращению к полям, что при работе не в пределах IDE (скажем на терминале сервера) может привести к
       плачевным последствиям.
    2) Свойства могут иметь неожидаемые последствия, например затрагивать состояние не только своего поля, а всего типа в целом, что 
       никак не ожидается при обращении к полю.
    3) Свойства могут замедлять работу приложения довольно ощутимо, в отличии от прямого обращения к полю, например онлайн запросами, 
       что тоже не ожидается.
    4) Свойства могут выкинуть исключение, которое может даже не ожидаться, что ведет к Runtime исключению.
    5) Свойства могут изменяться: последовательный повторный вызов одного и того же свойства может повлечь разное поведение или даже
       породить разное состояние обьекта. Пример: DateTime.Now. А ведь без знания этих ньюансов, использование этого свойства может
       быть опасным.
    6) Свойства могут обращаться к внешним обьектам, а ожидается к конкретному состоянию данного обьекта.
    7) Синхронизация при многопоточном программировании может не синхронизироваться.
    8) Свойство нельзя передавать через ref, out, in, ибо параметр с подобными операторами работать с выводом метода напрямую не могут,
       из-за чего придется исхитряться для минимизации накладных расходов.

Так же иногда требуются определения именно свойств, а не полей, для своей работы некоторых фреймворков, паттернов и т.п. Пример: 
Entity Framework, паттерн MVVM.

От CODE_GLOG: при отладке в Visual Studio свойства и неявные методы автоматически обновляются при переходе по каждой строчке, что может
убить сервак, трафик или операционку, в зависимости от реализации свойства. Чтобы это отключить надо зайти в:
    Средства/Параметры/Отладка/Общее/галочка "Включить вычисление свойств и других неявных вызовов методов"
