Типы делятся на 2 вида: ссылочные и значимые. Хоть большинство из них - ссылочные, чаще всего для операций используются значииые.
Значимые же дополнительно делятся на структуры (наследуемые от System.ValueType) и перечисления (System.ValueType.Enum). 
Экземпляры значимых типов в отличии от ссылочных имеют иную логику и они делятся на 2: некпакованые и упакованые. 

Неупакованые те обьекты, что находятся в стеке. Для них не создаются указатель на обьект тип и индекс блока синхронизации. Упакованые же
наобарот - почти ссылочные типы: находятся в куче, имеют оба недостающих члена, могут передоваться по ссылке. Правда они все равно 
имеют логику значимых типов.

Так же несколько типов, используемые чаще других имеют синтаксическое упращение, называемые примитивными, большинство из которых - значимые.

Значимые типы (кроме некоторых перечислений) не могут иметь null значения, посему при работе с ними не выполняется проверка на null. 

В C# копирование идет по значению, но для ссылочных значение - ссылка, а для значимых - соответствующее значение. Посему в методах,
ожидающих ссылочный тип, происходит упаковка - освобождение места в куче, копирование значений и добавления 2 вспомогательных, передача 
ссылки на новый, уже упакованый, экземпляр. Обратного действия упаковке нет, а передача занчимого типа из кучи в стек является распаковкой.

Распаковка упакованного значимого типа менее ресурсозатратна и является получением указателя на упакованный значимый тип, но часто 
сопровождается копированием в новый значимый тип. Сам указатель ссылается на унеупакованную часть значимого типа. Поскольку упакованый 
обьект может быть иметь значение null, распаковка сопровождается проверкой на null и проверяется совместимость упакованного типа с требуемым.

Те значимые типы, которые находятся в куче в виде членов типов - упакованы? По крайней мере на них можно ссылаться через тип.

Новые значимые типы редко нужны, а возможные условия для их определения:
	1) Частое обращение к его полям/свойствам или к нему целиком
	2) Малый размер: до 16 байт при копировании, т.е. ее передачи или чуть более только при обращении к его членам
	3) Неизменяемость его состояния (допускается возврат нового экземпляра при размере не более 16 байт)
	4) Связь с неуправляемым кодом, в котором ожидается и/или рекомендуется структура
	5) Критичная необходимость в значимом типе: критичность в производительности или используемом памяти
	6) Априорный запрет в производных и базовых типов (помимо System.ValueType и System.ValueType.Enum).

Все типы могут быть равными, но не все тождественными - только значимые неупакованые типы из-за того, что не могут ссылаться на один
и тот же обьект. Так для них логика равенства и тождественности должна быть переопределена в соответствии с своим типом, ибо для 
ссылочных типов Euals выполняется как тождество, а для значимых - равенство.

Желательно при определении типа, реализовать сравнение для:
	1) IComparable<T> - для логики сравнения
	2) IComparable - для работы с необобщенными типами
	3) Переопределить операторы сравнения
	4) IEquatable<T> - для реализации типабезопасного сравнения
	5) Euals - для равенства (почти обязательно для ValueType)
	6) GetHashCode - для асинхронности (почти обязательно для ValueType)