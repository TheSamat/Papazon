Поскольку литералы чисел имеют тип int, то при присваивании их типу byte происходит неявное приведение типов. При превышении 
доступного диапозона, компилятор запрещает присваивание без явного приведения:
byte a = 1000; //ошибка компиляции

Из-за этого рекомендуется использовать беззнаковые типы только в крайней необходимости

Так же это применимо к работе с выражениями, где byte нельзя сложить с int без приведения byte к int:
byte a = 12;
byte b = 1000 + a;

А так же из-за разницы в диапазонав типов, возможно переполнение типов, когда теряется часть информации:
Byte b = 100;
b = (Byte) (b + 200); //	256 * ((300) % 256) - (300) = 44
b = -100

По умолчанию выражения в C# выполняются в непроверяемом контексте переполнения, т.е. переполнение не считается за ошибку и не вызывает 
ошибку. Изменить это можно в настройках, изменяя параметр компиляции /checked. Для локальной проверки же используют операторы и 
контекстные меню(инструкции) checked/unchecked:

cheked выдает ошибку при потере данных, в то время как uncheked - наоборот:

b = checked((Byte) (100 + 200)); //Error
b = unchecked((Byte) (100 + 200)); //Ok
b = (Byte) checked(100 + 200); //300 в int не переполняется, так что Ок
checked
{
	b = (Byte) (b + 200);
}	//error

Заметка: checked влияет только на математические операции на подобии сложения/вычитания, умножения и еще приведения типов, но не для 
используемых внутки контекста методов. Для подобной проверки внутки метода, необходимо использовать checked в соответствующем методе.
Так же из-за cheked операции выполняются быстрее.

Внимание! System.Decimal даже при unchecked вызывает ошибку переполнения и он выполняется медленно. Не использовать без крайней 
необходимости.
