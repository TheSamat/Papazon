Несколько типов данных используются столь часто, что им упростили синтаксис в виде псевдонимов:
int a = 0;
заместо:
System.Int32 a = new System.Int32();
Все равно, что использовали псевдоним: using int = System.Int32	

        byte                               (0...255)                          8   
        sbyte                           (-128...127)                          8   not CLS
        short                        (-32 768...32 767)                       16   
        ushort                             (0...65 535)                       16  not CLS
        int                   (-2 147 483 648... 2 147 483 647)               32  
        uint                               (0... 4 294 967 295)               32  not CLS
        long      (-9 223 372 036 854 775 808... 9 223 372 036 854 775 807)   64  
        ulong                              (0...18 446 744 073 709 551 615)   64  not CLS
        float                               (...)                             32
        double                              (...)                             64
        demical   разделитель фиксирован    (...)                             128
        bool                               (0...1)                            1
        char      символы юникода          (0...)                             16  
        string    ссылочный неизменяемый
        object    ссылочный базовый
        dynamic   ссылочный не рекомендуется к использованию
        enum

byte и sbyte - единственная числовая пара у которых диапозоны рассавлены иначе

Приметивные типы не наследуются друг от друга, но все равно могут приводиться друг другу. При неявном разрешенном приведении от меньшего 
к большему, у CLR существуют IL команды. Если же требуется наоборот от большего к меньшему, то при приведении, у нас могут пропасть 
часть данных и делать это не рекомендуется.

Заметка: в C# все целые числа не округляются, а отбрасывают дробную часть.

Так же к ним применяются литеральная форма записи в таких функцмях как Console.WriteLine():
Console.WriteLine(123 + 456);	//123456
Console.WriteLine(123.ToString() + 456.ToString()); //1234556

Сами литералы выступают как типы, так что возможно следующее:
5.ToString();

Кроме того, выражения, состоящие из литералов вычисляются уже на этапе компиляции, повышая скорость:
Boolean found = false; // В готовом коде found присваивается 0
Int32 x = 100 + 20 + 3; // В готовом коде x присваивается 123
String s = "a " + "bc"; // ... s присваивается "a bc"

И наконец, компилятор «знает», как и в каком порядке интерпретировать
встретившиеся в коде операторы (в том числе +, -, *, /, %, &, ^, |, ==, !=, >, <, >=, <=,
<<, >>, ~, !, ++, &&, || -- и т. п.)

В целочисленные типы можно записывать двоичные числа, через знак подчеркивания:
int a = 0b0000_0011; //1

Все целочисленные типы по умолчанию int, а дробные - double, "" - string, '' - char, true/false - bool.
Также существуют постфиксы для литералов: m/M - decimal, d/D - double, f/F - float.