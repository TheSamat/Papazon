Значимым типам не нужно занимать место (память) в куче, они не затрагиваются сборкой мусора и к ним нельзя обратиться по указателю. 
Но обращаться к ним через указатель иногда нужно, например при сохранении структуры в обьекте типа ArrayList:

struct Point
{
	public int x, y;
}

public sealed class Program
{
    public static class Main()
    {
        ArrayList a = new ArrayList();
        Point p;
        for (int i=0; i<10; i++)
        {
            p.x = p.y = i;
            a.Add(p);
        }
    }
}


Из метода Add() типа ArrayList:

public virtual Int32 Add(Object value);

Выясняется, что передается Object, а это ссылочный тип, но у нас значимый. Следовательно необходимо получить ссылку на нас Point,
но мы ж не можем обращаться к нему. Следовательно нам необходимо переобразовать Point в обьект кучи с теми же полями и 
уже ссылку на него передать в Add(). Этот проесс называется упаковкой и он протекает в 3 шага:

1) В управляемой куче выделяется память обьемом в копируемую структуру + указатель на тип и индекс блока синхронизации.
2) Поля копируются в новый обьект
3) Возвращается адресс нового обьекта. Так значимый обьект стал ссылочным.

Упаковка выполняется автоматически, без специальных методов, так что знать обязательно.

Так упакованный значимый тип будет оставаться в куче до тех пор, пока не наступит очередной сеанс сборки мусора. Так жизненный цикл 
упакованного типа больше неупакованного. Но созданный значимый тип попрежнему останется, так что пользоваться им по прежнему 
будет возможно.

Распаковка же не является противоположностью упаковке, так как состоит только в получении указателя на
исходный значимый тип (поля), содержащихся в упаковке. Из-за этого менее ресурсозатратен, но зачастую после распаковки следует копирование:
Point a = (Point) a[0];

Распаковка применяется 2 шага:
1) Проверяется, не null ли ссылка. Если null - вызывается исключение.
2) Сравниваются тип упакованного типа с типом текущего значимого типа. При различии вызывается исключение:

int x=5;
Object o=x; //упаковка x; o - ссылка на новый х
short y = (short) o; //int != short, 

вызывается исключение 2го шага, ибо (short) используется для распаковки (не забваем, что упакованный значимый тип - ссылочный, и 
по сему не является полноценным значимым типом того же, но неупакованого типа, так упакованный int != неупакованный int.

int x=5;
Object o=x; //упаковка x; o - ссылка на новый х
short y = (short)(int)o; //распаковка + приведение

Point p;
p.x = p.y = 1;
Object o = p;	//упаковка p в o
p = (Point) o;	//распаковка о в р + копирование
p.x = 2;	//изменение p в стеке
o = p;		//упаковка измененного p в о

Этот код наглядно показывает операции с членами ArrayList, это ОЧеНь неэффективно.

Операции упаковки и распаковки неявны, но их эффект значительный, поэтому необходимо быть осмотрительным на их счет:

Int32 v = 5; 
Object o = v; //упаковка v в о
v = 123;
Console.WriteLine(v + ", " + (Int32) o); 
// Отображается "123, 5"

Здесь 4 операции упаковки/распаковки. Первый очевиден, но где другие? Это дело конкатенации - функции у которой куча перегруженных копий, 
различающиеся только количеством параметров:

public static String Concat(Object arg0, Object arg1, Object arg2)

Для arg0 v необходимо упаковать, а о вначале приводят в int распаковкой без копирования и последующим приведением, 
после он снова упаковывается для arg2. Убрав (Int32) мы избавимся от 2 лишних операций распаковки/упаковки.

Многие методы имеют множество перегруженных методов, принимающие множество значимых типов для работы с ними без упаковки. 
Но созданный свой значимый тип будет приводиться к Object. Так же вместо перегружения можно просто создавать обобщенные методы,
что тоже избавит от упаковки.

Так же можно для оптимизации проводить упаковку вручную, скажем заменой:
Console.WriteLine("{0}, {1}, {2}", v, v, v);
на 
Object o = v;
Console.WriteLine("{0}, {1}, {2}", o, o, o);

Тогда упаковка будет проводиться только раз мсесто 3х и выделенно 3 раза меньше лишней памяти (напомню, что при упаковке в 
куче создается ссылочный обьект, который пропадает только при сеансе сборки мусора).

Так же значимые типы не имеют индекса блока синхронизации, т.е. нельзя синхронизировать обращение к нему в многопоточном приложении.

Примечание: обобщенные классы коллекций лучше необобщенных производительностью и использованием памяти как раз таки из-за 
отсутствия подобных упаковок/распаковок, код обеспечивает меньшее количество сеансов сбора мусора, типы повышают свою производительность.
Так System.Collections.Generic.List<T> предпочтительней System.Collections.ArrayList.

Некпакованные значимые типы могут вызывать виртуальные методы, унаследованные или переопределенные этим типом, но методы 
ваших типов могут быть вызваны невиртуально, т.е. без переопределения. 

Кроме того, экземпляр значимого типа, используемый для вызова невиртуального метода не может быть упакован. Но если же 
переопределенным методом вызывается базовая реализация метода, то тип упаковывается для this базового метода. 

Но унаследованные невиртуальные методы (GetType/MemberwiseClone) требуют упаковки, так как они определены в System.Object, 
посему требуют Object.

Так же приведение неупакованного значимого типа к одному интерфейсу этого типа требует упаковки, так как интерфейсные переменные 
всегда должны отсылать к куче.


internal struct Point : IComparable {
  private Int32 m_x, m_y;

  // Конструктор, просто инициализирующий поля
  public Point(Int32 x, Int32 y) {
    m_x = x;
    m_y = y;
  }

  // Переопределяем метод ToString, унаследованный от System.ValueType
  public override String ToString() {
    // Возвращаем Point как строку (вызов ToString предотвращает упаковку)
    return String.Format("({0}, {1})", m_x.ToString(), m_y.ToString());
  }
  
  // Безопасная в отношении типов реализация метода CompareTo
  public Int32 CompareTo(Point other) {
    // Используем теорему Пифагора для определения точки,
    // наиболее удаленной от начала координат (0, 0)
    return Math.Sign(Math.Sqrt(m_x * m_x + m_y * m_y)
      - Math.Sqrt(other.m_x * other.m_x + other.m_y * other.m_y));
  }
  
  // Реализация метода CompareTo интерфейса IComparable
  public Int32 CompareTo(Object o) {
    if (GetType() != o.GetType()) {
      throw new ArgumentException("o is not a Point");
    }
    // Вызов безопасного в отношении типов метода CompareTo
    return CompareTo((Point) o);
  }
}

public static class Program {
  public static void Main() {
    
    // Создаем в стеке два экземпляра Point
    Point p1 = new Point(10, 10);
    Point p2 = new Point(20, 20);
    
    // p1 НЕ упакуется для вызова ToString (виртуальный переопределенный метод)
    Console.WriteLine(p1.ToString()); // "(10, 10)"
    
    // p1 УПАКУЕТСЯ для вызова GetType (невиртуальный метод)
    Console.WriteLine(p1.GetType()); // "Point"
    
    // p1 НЕ упакуется для вызова CompareTo (виртуальный переопределенный метод)
    // p2 НЕ упакуется, потому что вызван CompareTo(Point)
    Console.WriteLine(p1.CompareTo(p2)); // "-1"
    
    
    // p1 упакуется, а ссылка размещается в c
    IComparable c = p1;
    Console.WriteLine(c.GetType()); // "Point"
    
    // p1 НЕ упакуется для вызова CompareTo
    // Поскольку в CompareTo не передается переменная Point,
    // вызывается CompareTo(Object), которому нужна ссылка
    // на упакованный Point
    // c НЕ упакуется, потому что уже ссылается на упакованный Point
    // и НЕ распакуется, ибо нет обращения к полям
    Console.WriteLine(p1.CompareTo(c)); // "0"
    
    // c НЕ упакуется, потому что уже ссылается на упакованный Point
    // p2 УПАКУЕТСЯ, потому что вызывается CompareTo(Object)
    Console.WriteLine(c.CompareTo(p2));// "-1"
    
    // c распакуется, а поля копируются в p2
    p2 = (Point) c;
    
    // Убеждаемся, что поля скопированы в p2
    Console.WriteLine(p2.ToString());// "(10, 10)"
  }
}
Обьяснения:

ToString(). Это виртуальный метод, а они обычно требуют ссылки (чем p1 не является). Однако он переопределен в структуре, что 
не может иметь потомков и Jit-компилятор вызывает переопределеный метод невиртуально (напрямую) (виртуально же вызываются 
методы типов имеющих возможность иметь потомков, на которые может ссылаться переменная благодаря наследованию и полиморфизму,
так будет вызван метод на которую ссылается переменная). Но если бы метод был не переопределен, то вызвался бы базовый метод 
System.ValueType.ToString(), потребующий ссылки (object), то бишь упаковки.

GetType(). Это невиртуальный метод, а они не переопределяются, посему вызывается базовый метод, а он наследуется от System.Object, 
требующий Object, т.е. упаковки.

Point.CompareTo(Point p). Это виртуальный переопределенный метод сигнатурой в один Point, внутри которого посему не требует упаковки p2.

Приведение к IComparable. Поскольку интерфейсы - ссылки, необходимо упаковка с последующим приведением.

Point.CompareTo(Object). Поскольку c уже упакован, то в его упаковке нет нужды.

IComparable.CompareTo(Object); Поскольку c имеет тип IComparable то вызывается его метод IComparable, хоть он и ссылается на Point. 
А p2 не является Object, посему упаковывается.

Приведение к Point. Вначале распаковывается с, после же оператором = копируются в Point.


еще пример:
