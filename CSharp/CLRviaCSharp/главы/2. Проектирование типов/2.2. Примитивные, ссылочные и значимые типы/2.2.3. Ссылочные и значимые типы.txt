Есть 2 типа используемой программой памяти - стек (Stack) и куча (Heap). Оба не однородны и не так просты как может показаться. 
Куча - неупорядочная и бесконечна, пока это позволяет железо; стек - всегда размером в 1мб и не может быть расширена во время работы и 
выделяется для каждого потока в единственном экземпляре. Обоим выделяют место в оперативной памяти.

Большинство типов в c# - ссылочные, но чаще используются значимые. 

Для ссылочных типов верно следующее:
	1) пямять для ссылочных типов всегда выделяется из управляемой кучи
	2) каждый обьект, размещенный в куче, содержит дополнительные члены, подлежащие инициализации.
	3) незанятые полезной информацией байты обьекта (поля) обнуляются
	4) размещение обьекта в управляемой куче со временем инициализируют сборку мусора.

Но ссылочные типы медленные, для большинства частой, простой и эффективной работы нужны значимые типы. Их экземпляры находятся в стеке, 
вместе со своими полями (но могут и в куче в качестве поля). Поэтому разыменование (dereference) им не нужно (получение объекта 
по ссылке называется разыменованием). Их экземпляры не обрабатываются уборщиками мусора, уменьшается работа с кучей и количество 
сеансов уборки мусора.

Все классы - ссылочные, а структуры и перечисления (Enumeration) - значимые. 

Все значимые типы наследуются от абстрактного System.ValueType, что наследуется от System.Object, а все перечисления от System.Enum,
производного от System.ValueType. И все значимые типы изолированы, т.е. не могут быть унаследованы (int, long).

Копируя значимый тип, создается новый экземпляр, в который копируются все его значения, при этом для каждого поля создается свой экземпляр.
Для ссылочных копирование тоже сопровождается созданием новой переменной, но с той лишь разницей, что его значение - ссылка указатель на 
экземпляр, останется тем же, но новый экземпляр типа создаваться не будет.

Но и у значимых типов есть недостатки, как впрочем и у ссылочных:
	1) Обьекты значимого типа могут быть как неупакованы (unboxed), так и упакованы (boxed), в то время как ссылочные только упакованы.
	2) System.Object и System.ValueType имеют одинаковый функционал, но второй переопределяет методы Equals() и GetHashCode(). Для своих
	   (обоих видов) типов их лучше переопределить.
	3) Значимые типы изолированы, из-за чего нельзя создавать виртуальные, абстрактные методы, являясь неявно запечатанными 
	   (непереопределимыми)
	4) Ссылочные типы при создании переменной имеют значение null, в то время как значимые всегда имеют некое значение 
	   соответствующего типа (исключение есть).
	5) При копировании обьекта ссылочного типа, копируется только адрес его памяти, а значимого - значения всех его полей.
	6) Ссылаясь на один и тот же обьект переменные ссылочных типов по сути, изменяют значение этого обьекта для всех переменных, 
	   в то время как в значимых - наоборот.
	7) Так как неупакованные значимые типы не размещаются в куче, отведенная им память освобождается сразу после при возвращении методом, 
	   в котором он описан, в то время как ссылочные ожидают сборку мусора.

Заметка: абстрактно и практично для определения структуры необходимо, чтобы:
	1) Вел себя примитивно: не должен иметь возможности изменять состояние своих экземпляров во время работы. Структуры 
	   не должны иметь членов, изменяющие поля экземпляра ибо это могут сделать и интерфейсы от которых он наследуется, 
       посему стоит сделать не меняющиеся поля доступными только для чтения во избежания возможных проблем.
	2) Малый размер:
		I)  16 байт (мах размер при ValueType) в случае, если он будет передоваться/копироваться, 
		II) больше, но в случае, когда он не будет передоваться/копироваться.
	3) Ни от кого не наследуется и от него никто не будет наследоваться.

Заметка: указатель (ссылка) - просто адресс в памяти и весит 32 или 64 бита информации в зависимости от используемого ОС и процессора.