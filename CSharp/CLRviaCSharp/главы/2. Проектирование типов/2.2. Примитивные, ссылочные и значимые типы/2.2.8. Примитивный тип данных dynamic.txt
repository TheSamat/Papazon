C# обеспечивает безопасность типов, т.е. разрешает проводить те операции, разрешенные для этого типа. При этом еще при компиляции обнаруживаются ошибки использования типов и допускают больше допущений компилятору, IL коду и методанным. Но ошибки, возникающие во время выполнения кода вызывают ошибки/исключения,которы е необходимо вылавливать. Это в свою очередь громоздит код.

При работе только с C#, проблемы могут быть только во время работы с кодом при использовании отражений.

Но при работе с другими компанентами, написанные на динамических языках на подобии Python или работе с COM/DOM-обьектами, можно схватить кучу ошибок. Для работы с ними был придуман тип Dynamic. 

В динамический тип можно записать результат метода, а после обращаться к его членам класса, полей, свойств/индексаторов, методов, делигатов или унарных/бинарных операторов. При обращении к нему, компилятор создает специальный IL-код, называемый "полезной нагрузкой"(payload), описывающий операцию. Во время выполнения программы он динамически определяет операцию по своему действительному типу, на которую ссылается.

internal static class DynamicDemo{
  public static void Main(){
    dynamic value;
    for (int demo=0; demo<2; demo){
      value = (demo==0) ? (dynamic) 5: (dynamic) "A";
      value = value + value;
      M(value);
    }
  }
  private static void M(int n){
    Console.WriteLine("M(int): " + n);
  }
  private static void M(String s){
    Console.WriteLine("M(String): " + s);
  }

Вывод:
M(int): 10
M(String): AA

Для начала у оператора + операнды помечены как dynamic, из-за чего компилятор генерирует код полезной нагрузки, проверяющий действительный тип value во время выполнения и определяющий работу оператора +.

Во время вызова метода M тоже генерируется код полезной нагрузки, который определяет действительный тип и вызывает соответствующий сигнатуре перегруженный метод (или вызывает исключение, если такового не имеется)

Пометка dynamic в качестве типа поля, параметра метода или возвращяемого типа метода конвертируется в качестве типа object экземпляра System.Runtime.CompilerServices.DynamicAttribute. В случае же локальной переменной, то она будет определена как object (DynamicAttribute используется внутри метода), но уже с небольшими различиями. Из-за этого, кстати, object и dynamic имеют одинаковую сигнатуру.

Тип dynamic может определять аргументы обобщенных классов, структур, интерфейсов, делегатов или методов (все ссылочные и значимые типы (при этом они упаковываются)). При этом переменная конвертируется в object и применяет DynamicAttribute различным частям методанных. При этом обобщенный код просто компилируется как Object, из-за чего динамической отправки нет - не производится и полезная нагрузка.

К Object можно приводить любой тип неявно, но нельзя неявно приводить object к любому другому. Только явнным приведением можно это сделать. А dynamic можно:

Object o1 = 123; 
// OK: Неявное приведение Int32 к Object (упаковка)
Int32 n1 = o1; 
// Ошибка: Нет неявного приведения Object к Int32
Int32 n2 = (Int32) o1; 
// OK: Явное приведение Object к Int32 (распаковка)+копирование полей

dynamic d1 = 123; 
// OK: Неявное приведение Int32 к dynamic (упаковка)
Int32 n3 = d; 
// OK: Неявное приведение dynamic к Int32 (распаковка)+копирование полей

Но во время выполнения CLR проверяет безопасность при приведении типов и при их несовместимости выдает исключение.

Dynamic схож с var, за тем исключением, что var используется только внутри методов для обьевления локальных переменных, при этом должна быть явно обьявлена и к var нельзя приводить ни один тип. А обьявленную как dynamic переменную же нельзя инициализировать.

dynamic d = 123;
var result = M(d);

Код успешно скомпилируется, но компилятор не знает какая перегруженная реализация метода вызовется при выполнении кода и помечает result как dynamic. Если же Метод обявлен как void, т.е. не возвращает значения, то вызовится исключение.

При преобразовании dynamic из статистического в статистический результатом будет статистический тип и наоборот. А при создании же все зависит от создаваемого типа.

При импользовании dynamic в foreach / ресурс в using, компилятором генерируется код, пытающий привести выражение как System.IEnumerable / System.IDisposaable соответственно. При ошибке при приведении вызывается исключение.

При этом у dynamic типа можно спокойно вызывать поля, свойства, методы, для использования которых необходимо было бы явно приводить тип. На примере использования отражения/рефлекция для вызова метода Contains(String("ff")) для строки "Jeffrey Richter" и поместить его результат с типом int в лок. переменную result:

Object target = "Jeffrey Richter";
Object arg = "ff";

Type[] argTypes = new Type[] { arg.GetType() };
MethodInfo method = target.GetType()
	.GetMethod("Contains", argTypes);

Object[] arguments = new Object[] { arg };
Boolean result = Convert
	.ToBoolean(method.Invoke(target, arguments));

Для этого нам необходимо определить действующий тип находимого текста (предположим, мы не знаем его тип во время выполнения). Узнав его тип, находим метод целевого текста, реализующий желаемый метод, принимающий тип находимого текста. После же используем его. В псевдокоде это занело бы мало опраций, но сохранение безопасности не позволяет использовать методы обьектов, ибо у object обьекта их нет, а определение, приведение типов, поиск и применение метода занимает кучу кода и в придачу затратен по производительности.

dynamic же упрощает нам жизнь, перенося эти действия на компилятор:

dynamic target = "Jeffrey Richter";
dynamic arg = "ff";
Boolean result = target.Contains(arg);

Но используя динамический код необходимо выбрать либо высокую загруженность сборок либо оптимпльный расход памяти. В случае использования небольшого кол-во динамического кода рекомендуется использовать методы отражения для управляемых обектов либо приводить вручную типы для COM обьектов