Поскольку CLR зависим от типов, Microsoft создала спецификации CTS, описывающий способ определения и поведение типов. 
Согласно ей каждый тип может иметь нули и более членов, и иметь:

1) Поле. Переменную, инедфицируямая именем и типом. Является частью состояния обьекта.
2) Метод. Функция с именем, сигнатурой, модификациями, типом возвращаемых значений.
3) Свойство. Схож на поле, на деле 1-2 метода get/set
4) Событие. Используется для оповещения между обьектами.

А также прописывает видимость и доступ к членам типа:

1) private (закрытый) - только в рамках своего класса/структуры
2) private protected (защищенно-закрытый) - в рамках своего класса + для производных классов в одной сборке
3) protected (защищенный) - в рамках своего класса и для производных классов во всех сборках
4) internal (внутренний) - на уровне одной и той же сборки
5) protected internal (внутренне-защищенный) - всей своей сборке (даже не наследникам), а для других сборок - только наследникам
6) public (открытый) - для любой сборки

Текущий класс:                         1, 2, 3, 4, 5, 6
Производный класс из текущей сборки:      2, 3, 4, 5, 6
Производный класс из другой сборки:          3,    5, 6
Непроизводный класс из текущей сборки:          4, 5, 6
Непроизводный класс из другой сборки:                 6

Структуры не могут иметь protected модификаторы так как не могут быть унаследованы.

Еще CTS определяет правила управления наследования, виртуальными методами, сроком жизни обектов и т.д. Из-за этого 
компилятор C++/CLR не сможет наследоваться от нескольких типов.

Также каждый тип должен быть унаследоваться от класса object и позволить уметь следующее:

1) сравнить два экземпляра на равенство
2) получить хеш-код экземпляра
3) запросить фактический тип экземпляра
4) выполнить поверхностное (поразрядное) копирование экземпляра
5) получить строковое представление текущего состояния обьекта

