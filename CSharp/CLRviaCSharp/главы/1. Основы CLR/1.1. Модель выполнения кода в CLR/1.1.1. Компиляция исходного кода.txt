Среда выполлнения проги(CLR), в которой среда управляет памятью, загрузкой сборок, обезопасивает данные, 
обрабатывает исключения и синхронизирует разное; у всех языков схожа (если не одна и та же) и выполняет те же задачи 
анологичными способами: например, обработка ошибок через исключения.

По сути CRL не важно на каком языке написан код, если соответствующий компилятор поддерживает CRL, то можно 
не ограничиваться в одном языке.

Компилятор же проверяют исходный код на наличие разного рода ошибок, после генерируют код, называемый управляемым модулем 
(managed modul) для среды. У нашей среды это стандартный переносимый исполняемый (portable executable/PE) файл 32/64 
разрядности оперативной системы (Windowns PE 32/PE 32+)

Заметка: управляемые сборки всегда используют разные фичи безопасности для обеспечении её же для всей системы. У нас это 
"предотвращение выполнения данных"(DEF, Data Execution Prevention) и технология ASLR (Address Space Layout Optimization)

Компиляторы машинного кода генерируют код, оринтированный на конкретную процессорную архитектуру (х86, х64, ARM). В отличии 
от них CLR-совместимые компиляторы (в том числе наш компилятор c#) генерируют IL код, называемый управляемым (managed code), 
так как CLR занимается управлением его выполнения.

IL код - обьектно-ориентированный, стековый, безрегистровый, нетипезированный, верифецируемый язык программирования.
	обьектно-ориентированный: основан на принципах объектно-ориентированного программирования
	стековый: для передачи параметров используется машинная модель стека - первым пришел, первым вышел
	безрегистровый: не использует регистры памяти для работы
	нетипезированный: для языка нет различий между типами данных
	верифецируемый: обращение к памяти идет только к тем ячейкам, что гарантированно свободны

Управляемый модуль содержит в себе несколько частей:
	1. Заголовок PE32/PE32+. Стандартный заголовок PE-файла Windowns, анологичный COFF (Common Object File Format). В PE32 
	   может выполняться в 32/64 разрядных версиях Windows, PE64 только в 64х. Заголовок обозначает тип файла (GUI, CUI или DLL) и 
	   время сборки. Модули только с IL кодом игнорируют большую часть данных; а в модулях, содержащих машинный код, 
	   заголовок содержит сведениия о машинном коде.
	2. Заголовок CLR содержит информацию (интерпретируемую CLR и утилитами), которая превращает этот модуль в управляемый. 
	   Заголовок включает нужную версию CLR, некоторые флаги, метку метаданных MethodDef точки входа в управляемый модуль (метод Main),
	   а также месторасположение/размер метаданных модуля, ресурсов, строгого имени, некоторых флагов и пр.
	3. Методанные. Это таблицы. 	Есть 2 основных вида таблиц: описывающие типы данных и их члены из исходного кода, и 
	   анологичный для ссылок на члены типов из исходного кода.
	4. Сам код IL. Код, создаваемый компилятором при компиляции, который после CRL компилирует в машинные команды.

IL и методанные неотделимы. Методанные круты и могут:
	1. Сокращать использование памяти, так как все сведения об типах/членах компилятор читает напрямую из управляемого модуля.
	2. Упрящают написание кода в VSudio
	3. Обеспечивают безопасность типов при верификации кода
	4. Позволяют сериализировать поля обектов (хз зачем)
	5. Помогают сборщику мусора

Компиляция - сборка программы, включающая в себя: перевод всех модулей программы, написанных на языке программирования 
высокого уровня (например C#), в эквивалентные программные модули (в нашем случае упарвляемый) на низкоуровневом языке (IL), 
близком  к машинному коду(или на машинном языке в иных случаях) и сборку исполняемой программы. 

Сборка - уневерсальная единица повторного использования кода, позволяющая обьеденить логическое и физическое разделения кода. Во всем
мире эту единицу зовут компонентом, в то время как в .NET - сборкой.

Существует два вида компиляции:
	1) AOT-компиляция (ahead-of-time) – компиляция перед исполнением программы. Т.е. программа компилируется только один раз, 
	   в результате компиляции получается исполняемый файл. Во время AOT компиляции весь C# код преобразуется в IL код, не требуея 
	   выделения дополнительной памяти и проходит с минимальной нагрузкой на систему. 
	2) JIT-компиляция (just-in-time) – (динамическая) компиляция во время исполнения программы. Т.е. программа (а точнее, 
	   блоки программы) компилируется при каждом запуске. Здесь же из IL код в машинный. Во время JIT-компиляции каждый метод 
	   преобразуется лишь раз, поддерживая разные параметры. Оптимизация за счет динамической компиляции обгоняет машинный с помощью
	   различных механизмов JIT-компиляции.

Для каждого приложения создается свой домен - виртуальное пространство, которому соотвествует свой .exe файл. По умолчанию, это
значит, что каждому приложению соответствует один домен. Но создание виртуального пространства - излишне для верифицируемого CLR.