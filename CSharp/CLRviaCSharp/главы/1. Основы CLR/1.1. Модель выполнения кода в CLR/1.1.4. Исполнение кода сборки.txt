Модули имеют IL код. Сам же IL - не зависящий от процессора машинный язык, который к тому же отличается наличаием возможностей: 
работы с обьектами, виртуальные методы и манипулирование с элементами массивов, работы с исключениями, т.е. IL можно 
рассматривать как обьектно-ориентированный машинный язык.

IL код можно писать на языках высокого уровня, но также его можно написать на ассамблере IL(ILAsm.exe) или дизамблере 
IL(ILDasm.exe). При этом IL имеет все возможности CLR, что невозможно при написание анологичного кода на языках высокого уровня 
вроде C#.

Сам же IL код преобразуется в машинный код своим компилятором, называемым JIT-компилятором (Just In Time) среды CLR.

По итогу на примере HelloWorld.cs выходит следующая последовательность:
	1) При компиляции находим все типы данных, на которые ссыляется Main (в нашем случае это Console)
	2) Выделяет внутренние структуры данных, используемые для управления доступом к типам, на которые есть ссылки 
	(иннициализует Console). В этой структуре содержится по записи на каждый метод, а в записе - ссылка на внутреннюю 
	недокументированную реализацию функций в IL.
	3) Когда Main впервые обращается к методу WriteLine, вызывается соответствующая функция, компилирующий IL код 
	вызываемого метода в собственные команды процессора в слудующие 6 шагов, а после возвращает управление Main:
		1. Находим в методанных сборки реализуемый тип (Console) и вызываемый метод (WriteLine).
		2. Извлекаем из методанных IL реализацию метода
		3. Выделяем (динамически) блок памяти
		4. Откомпирируем IL в машинные команды в выделенную память
		5. Меняем точку входа метода в таблице методанных в выделенную память
		6. Передаем управление машинному коду в выделенной памяти
	4) При повторном обращении обращение идет напрямую к выделенной под нее память, а после тоже возвращает управление Main.

Поскольку Jit компилятор содержит реализацию в динамичной памяти, то при повторном запуске приложения он компилируется заново, 
но это не страшно, обращение к методу занимает обычно больше времени, чем его выполнение.

Компилятор C# имеет 2 параметра: optimize и debug
Входные параметры:			Il-код				Jit-код
/optimize-	/debug:full		Неоптимезирован		Оптимезирован
/optimize-	/debug:full		Оптимезирован		Неоптимезирован
/optimize-	/debug:full		Оптимезирован		Оптимезирован

	1) С optimize- компилятор C# генерирует неоптимизированный IL-код, содержащий дофига пустых команд. Они нужны для функции
	"изменить и продолжить"(edit and continue) в Visual Studio при откладке и упрощают откладку, позволяя установить 
	точки останова (breakpoints) на управляющий командах вроде for, while, do, if, else и блоках try, catch, finally. Во время 
	Jit компиляции эти команды удаляются, что усложняет отладку, но дает большее управление.
	2) С debug(+/full/pdbonly) компилятор C# создает файл PDB(Program Database). Файл PDB помогает отладчику находить локальные 
	переменные и связать команды IL с исходным кодом.
		debug:full указывает Jit-компилятору сохранять информацию о том какой машинный код был сгенерирован для каждой команды IL в отдельности, что упрощает отладку. Иначе ускоряется компиляция и сохраняется память(ибо сохранения нет)

В Visual Studio по дефолту в проекте устанавливаются /optimize- & /debug:full, а конфигурации выпуска /optimize+ & /debug:pdbonly

В С/С++ проги неуправляемы и для выполнения программ не выделяется доп память и код выполняется напрямую, но управляемые проги 
могут превосходить по производительными следующими фишками:
	1) Используются приоритетно спец команды процессоров, позволяя на физическом уровне оптимизировать код
	2) Однопроцессорные компьютеры не будут использовать даже проверку на наличие доп. процессоров, не говоря уже о 
	многопоточности и т.п.


